<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jQuery插件 与 zepto</title>
      <link href="2021/05/04/22-jQuery%E6%8F%92%E4%BB%B6%20%E4%B8%8E%20zepto/"/>
      <url>2021/05/04/22-jQuery%E6%8F%92%E4%BB%B6%20%E4%B8%8E%20zepto/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery插件-与-zepto"><a href="#jQuery插件-与-zepto" class="headerlink" title="jQuery插件 与 zepto"></a>jQuery插件 与 zepto</h1><h2 id="jQuery的插件"><a href="#jQuery的插件" class="headerlink" title="jQuery的插件"></a>jQuery的插件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>jQuery插件简介</span><br><span class="line">插件存在的意义：虽然jq很强大，，所以我们要自己实现。为了公用，我们会把它做成插件的形式。</span><br><span class="line">插件的本质：插件本身我们不直接对jq代码进行操作，而是间接和对jq代码进行修改。</span><br><span class="line">插件的分类</span><br><span class="line"><span class="number">1.</span>类级别插件</span><br><span class="line"><span class="number">2.</span>对象级别插件</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>封装jQuery插件</span><br><span class="line">  封装类级别插件</span><br><span class="line">  写法: $.extend(&#123;</span><br><span class="line">       方法<span class="number">1</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">      方法<span class="number">2</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;...</span><br><span class="line">  &#125;)</span><br><span class="line">  作用:类级别插件  相当于 给$添加方法   调用的时候 可以写作 $.方法<span class="number">1</span>()   $.方法<span class="number">2</span>()...</span><br><span class="line">  注意：<span class="number">1.</span>jQuery的插件js文件 命名应尽量写作 jQuery.xxx.js</span><br><span class="line">     <span class="number">2.</span>jQuery的插件封装应该尽量注意 在开头和 结尾 一定要加好分号  目的是为了压缩之后不会出问题</span><br><span class="line">       <span class="number">3.</span>在使用的时候 应该写作 $.方法()</span><br><span class="line">  </span><br><span class="line">  jQuery的隐式迭代：jQuery元素是一个伪数组 但在执行操作的时候 不需要循环 因为jQuery会自动帮助我们                    循环jQuery元素伪数组中的数组项。这就是隐式迭代</span><br><span class="line">                   隐式迭代的弊端 是 无法拿到 下标 如果想使用下标 依然需要手动循环</span><br><span class="line">  jQuery链式编程原理: jQuery元素.方法<span class="number">1</span>().方法<span class="number">2</span>().方法<span class="number">3</span>()...</span><br><span class="line">    原理是  jQuery的绝大部分方法 返回值为 调用方法的 jQuery元素</span><br><span class="line">                   例如： jQuery元素.方法() === 方法的返回值 === jQuery元素</span><br><span class="line">  但有小部分方法 返回值 不是调用方法的jQuery对象  例如：用来获取的方法（css，  attr,html,text,val,）</span><br><span class="line">  </span><br><span class="line">  封装对象级别插件</span><br><span class="line">  写法: $.fn.extend(&#123;</span><br><span class="line">      方法<span class="number">1</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">      方法<span class="number">2</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,...</span><br><span class="line">  &#125;)</span><br><span class="line">  作用: 对象级别插件 相当于 给jQuery元素对象 添加方法  调用的时候 写作 $(<span class="string">&quot;选择器&quot;</span>).方法<span class="number">1</span>()</span><br><span class="line">  注意：<span class="number">1.</span>jQuery的对象级别插件的方法 如果不是专门用来获取的  应该返回调用方法的jQuery元素 从而实现    链式编程</span><br><span class="line">        <span class="number">2.</span>调用jQuery对象级别插件的时候 应该使用 jQuery元素调用</span><br><span class="line"><span class="number">3.</span>第三方插件的使用</span><br></pre></td></tr></table></figure><h2 id="zepto"><a href="#zepto" class="headerlink" title="zepto"></a>zepto</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>zepto简介</span><br><span class="line">Zepto是移动端开发框架,是jQuery的轻量级代替品；API及语句同jQuery相似，但文件更小(可压缩至<span class="number">9.</span>6KB)。是目前功能完备的库中最小的一个。</span><br><span class="line">Zepto.js 中文文档：https:<span class="comment">//zeptojs.bootcss.com/ </span></span><br><span class="line"></span><br><span class="line">zepto的优点：</span><br><span class="line"><span class="number">1.</span>学习成本低  方法及用法几乎和jQuery完全一样</span><br><span class="line"><span class="number">2.</span>轻量级：压缩之后只有<span class="number">9.</span>6k</span><br><span class="line"><span class="number">3.</span>还可以兼容移动端</span><br><span class="line"></span><br><span class="line">为了保持原码的精简，Zepto默认只加载一些模块，当你需要某些模块时，可以把对应的模块加载进来。</span><br><span class="line">zepto源代码中内置了一些核心功能模块代码  另外一些非核心功能代码 如果需要使用 需要单独引入</span><br><span class="line"></span><br><span class="line">zepto和jQuery的区别</span><br><span class="line"><span class="number">1.</span>zepto的width和height方法 得到的是 元素自身宽高 + padding + border</span><br><span class="line">  zepto没有别的获取宽高的方法了。</span><br><span class="line"><span class="number">2.</span>zepto获取元素位置的方法 </span><br><span class="line">  offset :   元素.offset();   得到一个对象 对象有四个属性 height width left top  left和top相对    于页面计算距离</span><br><span class="line">  position:  元素.position(); 得到一个对象 对象有两个属性 left 和 top  相对于定位父元素计算距离</span><br><span class="line">zepto的移动端事件</span><br><span class="line"><span class="number">1.</span>使用移动端事件之前 必须引入touch模块</span><br><span class="line"><span class="number">2.</span>zepto的touch模块激活事件</span><br><span class="line">单击：tap</span><br><span class="line">双击：doubleTap</span><br><span class="line">长按：longTap</span><br><span class="line">滑动：swipe</span><br><span class="line">左滑：swipeLeft</span><br><span class="line">右滑：swipeRight</span><br><span class="line">上滑：swipeUp</span><br><span class="line">下滑：swipeDown</span><br><span class="line"></span><br><span class="line">jQuery实现表单序列化(如果在zepto中也可以直接使用 因为内置模块form可以实现)</span><br><span class="line"><span class="number">1.</span>serialize : jQuery表单元素.serialize()</span><br><span class="line"> 作用是直接将表单中input中输入的数据 序列化为一个字符串 键名=键值&amp;键名=键值...</span><br><span class="line"><span class="number">2.</span>serializeArray:  jQuery表单元素.serializeArray()</span><br><span class="line">               作用是将表单中input输入的数据 序列化为一个数组 数组中的数组项为对象 对象有两个属性    name和value  主要用来帮助用户获取和操作表单元素中输入的内容</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery动画和ajax</title>
      <link href="2021/05/04/21-jQuery%20%E5%8A%A8%E7%94%BB%20%E5%92%8C%20ajax/"/>
      <url>2021/05/04/21-jQuery%20%E5%8A%A8%E7%94%BB%20%E5%92%8C%20ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery-动画-和-ajax"><a href="#jQuery-动画-和-ajax" class="headerlink" title="jQuery 动画 和 ajax"></a>jQuery 动画 和 ajax</h1><h2 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">预制动画：这是提前制作好的动画方法 当用户调用的时候 可以实现指定的动画效果</span><br><span class="line"><span class="number">1.</span>显示隐藏动画</span><br><span class="line">           show：jQuery元素.show(动画时长,速度曲线,动画结束后执行的函数)</span><br><span class="line">  动画时长:单位为ms  直接写数字 不写单位  <span class="number">1000</span></span><br><span class="line">           速度曲线easing: linear：线性(匀速)   swing:先慢后快再慢(默认)</span><br><span class="line">  注意：上述三个参数 除了动画时长必须传  别的参数都可以不传 有默认值</span><br><span class="line">  补充：动画时长 可以直接传数字  也可以通过关键字进行设置 fast(200ms) normal(400ms)    slow(600ms);</span><br><span class="line">           hide：jQuery元素.hide()</span><br><span class="line">           toggle：jQuery元素.toggle()</span><br><span class="line"><span class="number">2.</span>上拉下拉动画</span><br><span class="line">           slideUp: jQuery元素.sliceUp(动画时长,速度曲线,动画结束后执行的函数)</span><br><span class="line">           slideDown</span><br><span class="line">           slideToggle</span><br><span class="line">           注意：上拉下拉动画 所有参数都可以不传 有默认值</span><br><span class="line"><span class="number">3.</span>淡入淡出动画</span><br><span class="line">           fadeIn: 用法同上</span><br><span class="line">           fadeOut</span><br><span class="line">           fadeToggle</span><br><span class="line">           fadeTo</span><br><span class="line">         弊端：不够灵活，只能实现固定的动画效果</span><br><span class="line">自定义动画：这是完全由用户进行自定义的动画。效果类似于我们之前封装过的缓冲动画</span><br><span class="line">  animate</span><br><span class="line">           <span class="number">1.</span>用法<span class="number">1</span>：jQuery元素.animate(&#123;要添加动画的属性:终点值,...&#125;,动画时间,速度曲线,动画执行  完后执行的函数)</span><br><span class="line">                   必须传的参数 对象</span><br><span class="line">                   动画时间：默认400ms</span><br><span class="line">                   速度曲线：默认swing</span><br><span class="line">                   函数：默认没有</span><br><span class="line">            <span class="number">2.</span>用法<span class="number">2</span>：jQuery元素.animate(&#123;要添加动画的属性:终点值...&#125;,&#123;</span><br><span class="line">                        duration:动画持续时间,</span><br><span class="line">                    easing:速度曲线,</span><br><span class="line">                        complete:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="comment">//动画完成执行的函数</span></span><br><span class="line">  queue:<span class="literal">true</span>/<span class="literal">false</span>,<span class="comment">//是否将当前动画添加到动画队列中 默认为true</span></span><br><span class="line">            &#125;)</span><br><span class="line">jquery的动画队列：当用户给一个元素连续添加多个动画的时候 添加的动画就会进行排队 并按照排队顺序 依次  执行，这就是jQuery的动画队列</span><br><span class="line">jQuery停止动画   stop</span><br><span class="line">用法: jQuery元素.stop(是否清空后续动画队列，是否立即执行到当前动画的终点)</span><br><span class="line">说明: 两个参数 都是 布尔值  <span class="literal">true</span> 表示 清空后续队列 并 立即执行到终点   <span class="literal">false</span> 表示不清空队列 不执行  到终点</span><br><span class="line">注意: 两个参数的默认值 都是<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">jQuery延迟动画  delay</span><br><span class="line">用法: jQuery元素.delay(n)  n就是延迟时间 单位为ms  不写单位</span><br><span class="line">作用: 将这个方法 在动画开始之前调用 就可以起到延迟指定时间 执行动画的效果</span><br><span class="line"></span><br><span class="line">jQuery操作动画队列</span><br><span class="line"><span class="number">1.</span>动画队列的插队方法 queue</span><br><span class="line">用法: jQuery元素.queue(<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123; 要插队的代码; next()&#125;);</span><br><span class="line">注意: 形参next 会接收到一个函数 这个函数的作用 是让插队代码后面的动画队列能正常执行 只要调用这个函   数就可以解决 后续动画队列的问题</span><br></pre></td></tr></table></figure><h2 id="jQuery的ajax"><a href="#jQuery的ajax" class="headerlink" title="jQuery的ajax"></a>jQuery的ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1.jQuery的ajax方法</span><br><span class="line">用法: $.ajax(&#123;</span><br><span class="line">url:&quot;请求的后台url地址&quot;,   必传</span><br><span class="line">type:&quot;请求方式&quot;,    非必传 默认值为get</span><br><span class="line">dataType:&quot;前后台交互的数据格式&quot;,   非必传 默认值为json  可以传 json xml text</span><br><span class="line">data:前端向后台提交的数据,  非必传 默认值为空串</span><br><span class="line">timeout:超时时间(是一个数字 单位为ms 一般设置为10000) , 非必传 默认为0s</span><br><span class="line">         beforeSend:function()&#123; 这个函数会在请求发送之前执行 &#125;, 非必传</span><br><span class="line">         success:function(res)&#123; 这个函数会在请求成功时执行 形参res可以接收到响应数据 &#125;, 必传</span><br><span class="line">         error:function(err)&#123; 这个函数会在请求失败时执行 形参err可以接收到响应失败信息&#125;, 非必传</span><br><span class="line">         complete:function()&#123; 这个函数会在请求响应完成的时候 执行 &#125;,  非必传</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> jQuery的ajax方法 获取到的数据 可以直接使用 因为jQuery已经提前做过处理了</span><br><span class="line"> </span><br><span class="line">2.jQuery的get方法</span><br><span class="line">用法: $.get(&quot;地址&quot;,&#123;键名:键值,键名:键值,...&#125;,function(res)&#123; res可以接收到响应数据 &#125;)</span><br><span class="line">说明: get方法用来发送ajax请求  但只能发送get方法的请求  地址参数规定请求地址(必传) 对象参数规定提交的数据(非必传) 函数参数在请求成功时执行 形参可以接收到响应数据(必传)</span><br><span class="line"></span><br><span class="line">3.jQuery的post方法</span><br><span class="line">用法 和 作用 和get方法 完全一样</span><br><span class="line"></span><br><span class="line">4.跨域问题</span><br><span class="line">互联网为了提高自己的数据安全性 设置了一种策略 叫做 同源策略</span><br><span class="line">同源策略：如果两个网页 协议、域名、端口号 三者都一样 就可以互相访问数据 否则 不能互相访问数据</span><br><span class="line">协议 域名 端口号三者都相同的两个页面 成为同源页面  如果有一个不相同 则称二者为跨域页面</span><br><span class="line">https:&#x2F;&#x2F;www.baidu.com:80</span><br><span class="line"></span><br><span class="line">很多情况下 我们需要进行跨域数据交互  但同源策略阻断了这种可能性  因此后来人们就想出了跨域请求数据的方法-----jsonp</span><br><span class="line"></span><br><span class="line">jsonp并不是一个独立的技术  而是利用了 src属性天生可以跨域获取数据的功能 实现跨域获取数据的效果</span><br><span class="line">src属性 天生具备 跨域获取数据功能</span><br><span class="line"></span><br><span class="line">原生js实现jsonp跨域请求数据的思路</span><br><span class="line">1.创建script标签 </span><br><span class="line">2.设置script标签的src属性为 跨域请求的地址</span><br><span class="line">3.将script标签追加到页面中</span><br><span class="line"></span><br><span class="line">jQuery的jsonp: 直接使用jQuery的ajax 方法 请求跨域地址 之后 将dataType设置为jsonp即可</span><br><span class="line">写法：$.ajax(&#123;</span><br><span class="line">url:&quot;跨域地址&quot;,</span><br><span class="line">dataType:&quot;jsonp&quot;,</span><br><span class="line">success:function(res)&#123; res就可以接收到跨域响应数据 &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">jsonp这个技术 只能使用get发送请求  如果想使用post发请求 并跨域获取数据 可以使用CORS这个技术栈获取</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery的DOM BOM 和 事件</title>
      <link href="2021/05/04/20-jQuery%E7%9A%84DOM%20BOM%20%E5%92%8C%20%E4%BA%8B%E4%BB%B6/"/>
      <url>2021/05/04/20-jQuery%E7%9A%84DOM%20BOM%20%E5%92%8C%20%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery的DOM-BOM-和-事件"><a href="#jQuery的DOM-BOM-和-事件" class="headerlink" title="jQuery的DOM BOM 和 事件"></a>jQuery的DOM BOM 和 事件</h1><h2 id="1-jQuery操作BOM"><a href="#1-jQuery操作BOM" class="headerlink" title="1.jQuery操作BOM"></a>1.jQuery操作BOM</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">获取元素宽高</span><br><span class="line">jQuery元素.width/height()   只包含元素自身宽高</span><br><span class="line">jQuery元素.innerWidth/Height() 元素自身宽高 + padding</span><br><span class="line">jQuery元素.outerWidth/Height() 元素自身宽高 + padding + border</span><br><span class="line">jQuery元素.outerWidth(<span class="literal">true</span>)/Height(<span class="literal">true</span>)  原色自身宽高 + padding + border + margin</span><br><span class="line">操作元素位置</span><br><span class="line">$(<span class="built_in">window</span>).width/height()  获取可视窗口的宽高</span><br><span class="line">$(<span class="built_in">document</span>).width/height()  获取页面内容宽高</span><br><span class="line"></span><br><span class="line">获取元素位置</span><br><span class="line">offset:  jQuery元素.offset()    得到的结果是一个对象 &#123;<span class="attr">left</span>:当前元素距离页面左侧的距离,<span class="attr">top</span>:距离页面顶部的距离&#125;</span><br><span class="line">position: jQuery元素.position()    得到的结果是一个对象 &#123;<span class="attr">left</span>:当前元素距离带定位父元素左侧的距离,<span class="attr">top</span>:距离带定位父元素顶部的距离&#125;</span><br></pre></td></tr></table></figure><h2 id="2-jQuery操作DOM"><a href="#2-jQuery操作DOM" class="headerlink" title="2.jQuery操作DOM"></a>2.jQuery操作DOM</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建jQuery元素</span><br><span class="line">  $(<span class="string">&quot;&lt;li&gt;张三&lt;/li&gt;&quot;</span>)   这样就创建出了一个 内容为 张三的 li</span><br><span class="line"><span class="number">2.</span>追加jQuery元素</span><br><span class="line"><span class="comment">//append类追加方法  比较死板 只能在父元素 开头或结尾 追加</span></span><br><span class="line">在父元素的末尾添加</span><br><span class="line">append：$(父元素).append(新子元素);</span><br><span class="line">appendTo: $(新子元素).appendTo(父元素)</span><br><span class="line">在父元素的开头添加</span><br><span class="line">prepend：$(父元素).prepend(新子元素);</span><br><span class="line">prependTo：$(新子元素).prependTo(父元素)</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert系列追加方法  比较灵活 可以在父元素任意位置 追加</span></span><br><span class="line">在某个元素之前插入</span><br><span class="line">before ：$(参考元素).before（新子元素）</span><br><span class="line">insertBefore：$(新子元素).insertBefore(参考节点)</span><br><span class="line">在某个元素之后插入</span><br><span class="line">after：$(参考元素).after（新子元素）</span><br><span class="line">insertAfter:$(新子元素).insertAfter(参考节点)</span><br><span class="line">总结：jQuery中 所有追加元素的方法 如果追加的是 页面上已经存在的元素 都会产生物理位移</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>删除jQuery元素</span><br><span class="line">remove: jQuery元素.remove() 删除当前元素</span><br><span class="line">detach: jQuery元素.detach() 删除当前元素</span><br><span class="line">empty: jQuery元素.empty() 清空当前元素</span><br><span class="line">remove和detach的区别：remove删除元素的时候 会连同事件一起删除  而 detach则会保留被删除元素的事件</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>克隆元素</span><br><span class="line">clone: jQuery元素.clone();   直接克隆得不到事件</span><br><span class="line">       jQuery元素.clone(<span class="literal">true</span>);   深层克隆 可以得到事件</span><br><span class="line"><span class="number">5.</span>替换元素</span><br><span class="line">replaceWith:旧jQuery元素.replaceWith(新jQuery元素)  用新jQuery元素 替换掉 旧jQuery元素</span><br><span class="line">replaceAll: 新jQuery元素.replaceAll(<span class="string">&#x27;选择器&#x27;</span>)  用新jQuery元素 替换掉 旧jQuery元素</span><br><span class="line"><span class="number">6.</span>包裹节点</span><br><span class="line">wrap: jQuery元素.wrap(用来包裹的jQuery元素)  可以使用用来包裹的元素 包裹住 原来的jQuery元素</span><br><span class="line">wrapAll: jQuery元素.wrapAll(用来包裹的元素)  使用用来包裹的元素 抱住 所有的原jQuery元素</span><br><span class="line">wrapInner: jQuery元素.wrapInner(用来包裹的元素) 给原jQuery元素中 嵌套一层用来包裹的元素</span><br><span class="line">unwrap: jQuery元素.unwrap()  删除掉当前jQuery元素的父元素</span><br><span class="line">注意：unwrap删除的父元素 如果是body 则删除失败</span><br></pre></td></tr></table></figure><h2 id="3-jQuery的事件绑定"><a href="#3-jQuery的事件绑定" class="headerlink" title="3.jQuery的事件绑定"></a>3.jQuery的事件绑定</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>jQuery添加事件的方法</span><br><span class="line">jQuery元素.事件名(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;处理函数&#125;)  可以给同一元素添加多个同类事件</span><br><span class="line"><span class="number">2.</span>jQuery绑定事件的方法</span><br><span class="line">jQuery元素.on(<span class="string">&quot;事件名&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;处理函数&#125;) </span><br><span class="line">jQuery元素.on(<span class="string">&quot;事件名1 事件名2 ...&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;处理函数&#125;)  弊端：所有事件共用一个处理函数</span><br><span class="line">jQuery元素.on(&#123;</span><br><span class="line">    事件名<span class="number">1</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    事件名<span class="number">2</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,...</span><br><span class="line">&#125;)  可以灵活的设置 每一个事件的 处理函数</span><br><span class="line">jquery自定义事件</span><br><span class="line">jQuery元素.on(<span class="string">&quot;自定义事件名&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;处理函数&#125;)</span><br><span class="line">jQuery元素.trigger(<span class="string">&quot;自定义事件名&quot;</span>)  </span><br><span class="line">注意：如果想执行自定义事件 需要调用trigger方法</span><br><span class="line"><span class="number">3.</span>jQuery的事件对象</span><br><span class="line">jQuery元素.on(<span class="string">&quot;事件名称&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123; ev就是事件对象 &#125;)</span><br><span class="line">clientX、clientY：鼠标的位置，可视区为基准点</span><br><span class="line">pageX、pageY：鼠标的位置，页面为基准点</span><br><span class="line">target事件目标</span><br><span class="line">ctrlKey、altKey、shiftKey：功能键</span><br><span class="line">ev.which相当于keyCode,比keyCode强大,还可以记录鼠标的键值,<span class="number">123</span>(左中右);</span><br><span class="line">ev.delegateTarget事件绑定的对象</span><br><span class="line">offsetX、offsetY 获取当前鼠标到添加事件的元素的左侧和顶部的距离</span><br><span class="line">screenX、screenY 获取当前鼠标到屏幕左侧和顶部的距离</span><br><span class="line"><span class="number">4.</span>jQuery的事件委托</span><br><span class="line">jQuery父元素.on(<span class="string">&quot;事件名&quot;</span>,<span class="string">&quot;子元素选择器&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"><span class="number">5.</span>jQuery取消事件绑定(解绑事件)</span><br><span class="line">用法: jQuery元素.off(<span class="string">&quot;事件名&quot;</span>);</span><br><span class="line">作用: 一次性解绑掉 指定事件名的 所有事件</span><br><span class="line">弊端: 可以一次性解绑所有事件 但是过于武断 不够灵活。</span><br><span class="line"><span class="number">6.</span>命名空间</span><br><span class="line">用法: jQuery元素.on(<span class="string">&quot;事件名.命名空间名&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">例如: $(<span class="string">&quot;li:eq(0)&quot;</span>).on(<span class="string">&quot;click.a&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"> $(<span class="string">&quot;li:eq(0)&quot;</span>).on(<span class="string">&quot;click.b&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">      这时如果我们想解绑掉第一个点击事件 就可以写作如下代码</span><br><span class="line">      $(<span class="string">&quot;li:eq(0)&quot;</span>).off(<span class="string">&quot;click.a&quot;</span>);</span><br><span class="line"><span class="number">7.</span>one</span><br><span class="line">用法: jQuery元素.one(<span class="string">&quot;事件名&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">作用: one也可以给jQuery元素绑定事件 但该事件只执行一次</span><br><span class="line"><span class="number">8.</span>hover</span><br><span class="line">用法: jQuery元素.hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;鼠标移入元素执行的函数&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;鼠标移出元素执行的函数&#125;)</span><br><span class="line">作用: hover是将鼠标移入移出事件 合并而成的 方法  </span><br><span class="line">注意: hover是mouseenter和mouseleave合并而成的事件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery的初识</title>
      <link href="2021/05/04/19-jQuery%E7%9A%84%E5%88%9D%E8%AF%86/"/>
      <url>2021/05/04/19-jQuery%E7%9A%84%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery的初识"><a href="#jQuery的初识" class="headerlink" title="jQuery的初识"></a>jQuery的初识</h1><h2 id="jQuery的初识-1"><a href="#jQuery的初识-1" class="headerlink" title="jQuery的初识"></a>jQuery的初识</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">jQuery是一个优秀的javascript库。</span><br><span class="line"></span><br><span class="line">jQuery凭借简洁的语法和跨平台的兼容性，极大的简化了javascript开发人员**遍历html文档**、**操作DOM**、**处理事件**、**执行动画和开发ajax的操作**。 </span><br><span class="line"></span><br><span class="line">jQuery强调的理念是以最少的代码，实现最多的功能。（write less <span class="keyword">do</span> more）</span><br><span class="line"></span><br><span class="line">jQuery的优点</span><br><span class="line"><span class="number">1</span>、轻量级 : jQuery压缩之后 可以精简到30kb</span><br><span class="line"><span class="number">2</span>、强大的选择器 : jquery支持所有css3的选择器来获取元素</span><br><span class="line"><span class="number">3</span>、出色的DOM操作的封装</span><br><span class="line"><span class="number">4</span>、可靠的事件处理机制</span><br><span class="line"><span class="number">5</span>、完善的ajax</span><br><span class="line"><span class="number">6</span>、不污染顶级变量 : jQuery有一个入口函数，类似于<span class="built_in">window</span>.onload 可以将jQuery的代码 和 全局作用域隔                   离开，由于在入口函数中声明的变量和函数都是局部变量 因此就不会污染顶级变量<span class="built_in">window</span></span><br><span class="line"><span class="number">7</span>、出色的浏览器兼容 : jQuery解决了所有浏览器兼容问题 因此我们可以放心使用jQuery的所有方法不用做兼                     容（仅限于jQuery1.x版本）</span><br><span class="line"><span class="number">8</span>、链式操作方式 : jquery元素.jQuery方法<span class="number">1</span>().jquery方法<span class="number">2</span>().jquery方法<span class="number">3</span>()....</span><br><span class="line"><span class="number">9</span>、隐式迭代 : jQuery批量获取的元素 直接给伪数组添加事件 就可以 不需要循环。因为jQuery已经帮我们循              环过了</span><br><span class="line"><span class="number">10</span>、行为层和结构层的分离</span><br><span class="line"><span class="number">11</span>、丰富的插件支持</span><br><span class="line"><span class="number">12</span>、完善的文档</span><br><span class="line"><span class="number">13</span>、开源</span><br><span class="line"></span><br><span class="line">正式开始jQuery</span><br><span class="line"><span class="number">1.</span>引入jQuery库文件</span><br><span class="line">  本地引入：将jQuery库文件 下载到本地 之后引入</span><br><span class="line">  线上引入：直接从线上地址 引入jQuery库文件</span><br><span class="line"><span class="number">2.</span>jQuery的入口函数(页面加载函数)</span><br><span class="line">  完整写法：jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; jQuery代码 &#125;);</span><br><span class="line">  简便写法：jQuery(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; jQuery代码 &#125;);</span><br><span class="line">  jQuery这个函数对象 在代码中 可以使用 $来表示  $ === jQuery</span><br><span class="line">  因此我们一般写作：$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; jQuery代码 &#125;)</span><br><span class="line">  </span><br><span class="line">  jQuery的入口函数作用：jQuery入口函数中的代码 会在 页面上的 结构、样式加载完之后 执行</span><br><span class="line">  <span class="built_in">window</span>.onload 中的代码 会在 页面结构 样式 和 外部引入的资源都加载完 再执行</span><br><span class="line">  </span><br><span class="line">  jQuery的入口函数 可以防止全局变量<span class="built_in">window</span>的污染</span><br><span class="line"><span class="number">3.</span>jQuery对象</span><br><span class="line">  jQuery元素对象的获取方法：$(<span class="string">&quot;css3选择器&quot;</span>)</span><br><span class="line">  注意：jQuery获取的元素 都是伪数组</span><br><span class="line">  </span><br><span class="line">  jQuery元素和DOM元素有什么区别</span><br><span class="line">  <span class="number">1.</span>jQuery元素只能用jQuery的方法  DOM元素只能用DOM的方法</span><br><span class="line">  某些情况下 jQuery方法和DOM方法需要混合使用  而jQuery和DOM的方法又不能混用 我们就需要将jQuery元   素和DOM元素进行转换</span><br><span class="line">  jQuery---&gt;DOM : jQuery元素是一个伪数组 其数组项就是DOM元素  因此如果想转DOM元素                                 写作jquery元素[下标]</span><br><span class="line">  DOM---&gt;jQuery : $(DOM元素)  </span><br><span class="line"><span class="number">4.</span>jQuery解决多库共存问题</span><br></pre></td></tr></table></figure><h2 id="jQuery的选择器"><a href="#jQuery的选择器" class="headerlink" title="jQuery的选择器"></a>jQuery的选择器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>基础选择器</span><br><span class="line">$(<span class="string">&#x27;元素名&#x27;</span>)：获取对应元素名的标签  $(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line">$(<span class="string">&#x27;.类名&#x27;</span>)：获取对应类名的标签 $(<span class="string">&#x27;.box&#x27;</span>),</span><br><span class="line">$(<span class="string">&#x27;#id名&#x27;</span>)：获取对应id名的标签 $(<span class="string">&#x27;#box&#x27;</span>),</span><br><span class="line"><span class="number">2.</span>层级选择器</span><br><span class="line">$(<span class="string">&#x27;a b&#x27;</span>)：获取a元素的后代元素b,</span><br><span class="line">$(<span class="string">&#x27;a&gt;b&#x27;</span>)：获取a元素的直接后代元素b,</span><br><span class="line">$(<span class="string">&#x27;a+b&#x27;</span>)：获取紧跟在a元素后面的b元素,  要求b元素紧跟在a元素后面</span><br><span class="line">$(<span class="string">&#x27;a~b&#x27;</span>)：获取a元素后面的所有b元素,   b元素只要在a元素后面就能获取到</span><br><span class="line"><span class="number">3.</span>基础过滤选择器</span><br><span class="line">$(<span class="string">&#x27;li:first&#x27;</span>)：获取第一个li元素</span><br><span class="line">$(<span class="string">&#x27;li:last&#x27;</span>)：获取最后一个li元素</span><br><span class="line">$(<span class="string">&#x27;li:not(.box)&#x27;</span>)：获取所有的li，除了<span class="class"><span class="keyword">class</span>名为<span class="title">box</span>的</span></span><br><span class="line">$(&#x27;li:even&#x27;)：获取索引为偶数的li元素</span><br><span class="line">$(<span class="string">&#x27;li:odd&#x27;</span>)：获取索引为奇数的li元素</span><br><span class="line">$(<span class="string">&#x27;li:eq(2)&#x27;</span>)：获取索引值为<span class="number">2</span>的li元素</span><br><span class="line">$(<span class="string">&#x27;li:gt(2)&#x27;</span>)：获取索引大于<span class="number">2</span>的li元素</span><br><span class="line">$(<span class="string">&#x27;li:lt(2)&#x27;</span>)：索引小于<span class="number">2</span>的li元素</span><br><span class="line"><span class="number">4.</span>可见性过滤选择器</span><br><span class="line">$(<span class="string">&quot;li:visible&quot;</span>) 获取可见的元素</span><br><span class="line">$(<span class="string">&quot;li:hidden&quot;</span>)  获取不可见元素</span><br><span class="line"><span class="number">5.</span>内容过滤选择器</span><br><span class="line">$(<span class="string">&quot;li:has(标签名)&quot;</span>) 获取内容中带指定标签名的标签的li</span><br><span class="line">$(<span class="string">&quot;li:contains(文本内容)&quot;</span>) 获取内容中带指定文本内容的li</span><br><span class="line">$(<span class="string">&quot;li:empty&quot;</span>) 获取内容为空的li</span><br><span class="line"><span class="number">6.</span>属性过滤选择器</span><br><span class="line">$(<span class="string">&quot;li[属性名]&quot;</span>) 获取带有指定属性的li</span><br><span class="line">$(<span class="string">&quot;li[属性名=属性值]&quot;</span>) 获取带有指定属性 且属性值为指定值的 li</span><br><span class="line">$(<span class="string">&quot;li[属性名!=属性值]&quot;</span>) 获取带有指定属性 且属性值不是指定值的 li</span><br><span class="line">$(<span class="string">&quot;li[属性名^=属性值]&quot;</span>) 获取带有指定属性 且属性值以指定值开头的 li</span><br><span class="line">$(<span class="string">&quot;li[属性名$=属性值]&quot;</span>) 获取带有指定属性 且属性值以指定值结尾的 li</span><br><span class="line">$(<span class="string">&quot;li[属性名*=属性值]&quot;</span>) 获取带有指定属性 且属性值包含指定值的 li</span><br><span class="line"><span class="number">7.</span>子元素过滤选择器</span><br><span class="line">$(<span class="string">&quot;li:first-child&quot;</span>) 获取第一个li</span><br><span class="line">$(<span class="string">&quot;li:last-child&quot;</span>) 获取最后一个li</span><br><span class="line">$(<span class="string">&quot;li:nth-child(n)&quot;</span>) 获取序号为n的li</span><br><span class="line">$(<span class="string">&quot;li:nth-child(odd)&quot;</span>) 获取序号为奇数的li</span><br><span class="line">$(<span class="string">&quot;li:nth-child(even)&quot;</span>) 获取序号为偶数的li</span><br><span class="line">$(<span class="string">&quot;li:nth-child(公式)&quot;</span>) 获取序号满足公式的li   </span><br><span class="line"><span class="number">8.</span>表单过滤选择器</span><br><span class="line">$(<span class="string">&quot;option:selected&quot;</span>) 获取被选中的下拉列表项</span><br><span class="line">$(<span class="string">&quot;input:checked&quot;</span>) 获取被选中的多选框</span><br><span class="line">$(<span class="string">&quot;input:disabled&quot;</span>) 获取被禁用的input</span><br><span class="line"><span class="number">9.</span>表单选择器</span><br><span class="line">$(<span class="string">&quot;:text&quot;</span>) 获取文本输入框input</span><br><span class="line">$(<span class="string">&quot;:password&quot;</span>) 获取密码输入框input</span><br><span class="line">$(<span class="string">&quot;:number&quot;</span>) </span><br><span class="line">$(<span class="string">&quot;:checkbox&quot;</span>) </span><br><span class="line">$(<span class="string">&quot;:radio&quot;</span>) </span><br><span class="line">$(<span class="string">&quot;:file&quot;</span>) </span><br><span class="line">$(<span class="string">&quot;:input&quot;</span>) 获取到所有表单元素</span><br></pre></td></tr></table></figure><h2 id="jQuery的简单操作"><a href="#jQuery的简单操作" class="headerlink" title="jQuery的简单操作"></a>jQuery的简单操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>遍历子节点</span><br><span class="line">jQuery元素.children()  得到所有当前jQuery元素的子元素</span><br><span class="line"><span class="number">2.</span>遍历兄弟节点</span><br><span class="line">jQuery元素.next().css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="comment">// 当前元素的下一个兄弟节点</span></span><br><span class="line">jQuery元素.nextAll().css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="comment">// 当前元素的下面所有的兄弟节点</span></span><br><span class="line">jQuery元素.prev().css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="comment">// 当前元素的上一个兄弟节点</span></span><br><span class="line">jQuery元素.prevAll().css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="comment">// 当前元素的上面所有的兄弟节点</span></span><br><span class="line">jQuery元素.siblings().css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="comment">// 当前元素的兄弟节点</span></span><br><span class="line"><span class="number">3.</span>遍历父节点c</span><br><span class="line">jQuery元素.parent();  获取直接父元素</span><br><span class="line">jQuery元素.parents();   获取所有父元素 到html为止</span><br><span class="line"><span class="number">4.</span>过滤遍历节点</span><br><span class="line">find : jQuery元素.find(<span class="string">&quot;选择器&quot;</span>);  可以获取jQuery元素中满足选择器条件的子元素</span><br><span class="line">filter : jQuery元素.filter(<span class="string">&quot;选择器&quot;</span>); 可以获取到指定jQuery元素中满足选择器条件的元素</span><br><span class="line">not : jQuery元素.not(<span class="string">&quot;选择器&quot;</span>);  可以获取到不满足选择器条件的元素</span><br><span class="line"></span><br><span class="line">操作属性</span><br><span class="line">attr:</span><br><span class="line"><span class="number">1.</span>获取属性: jQuery元素.attr(<span class="string">&#x27;属性名&#x27;</span>)</span><br><span class="line">    <span class="number">2.</span>设置属性: jQuery元素.attr(<span class="string">&#x27;属性名&#x27;</span>,<span class="string">&#x27;属性值&#x27;</span>)</span><br><span class="line">     这个方法可以操作任何属性</span><br><span class="line">     批量设置属性的操作: jQuery元素.attr(&#123;属性名:属性值,属性名:属性值,...&#125;) </span><br><span class="line">     弊端:获取表单元素的属性（disabled、chedcked、selected） 如果使用attr 并不利于进行判断</span><br><span class="line">prop:</span><br><span class="line">    <span class="number">1.</span>获取属性: jQuery元素.prop(<span class="string">&#x27;属性名&#x27;</span>);</span><br><span class="line">    <span class="number">2.</span>设置属性: jQuery元素.prop(<span class="string">&quot;属性名&quot;</span>,<span class="string">&quot;属性值&quot;</span>);</span><br><span class="line">prop方法主要用来操作表单元素的属性(disabled、chedcked、selected) 获取时得到的值是<span class="literal">true</span>或         <span class="literal">false</span> 设置也使用<span class="literal">true</span>或<span class="literal">false</span>进行设置</span><br><span class="line"></span><br><span class="line">操作类名</span><br><span class="line">addClass: 添加类名  jQuery元素.addClass(<span class="string">&quot;类名&quot;</span>)</span><br><span class="line">removeClass: 移除类名  jQuery元素.removeClass(<span class="string">&quot;类名&quot;</span>)</span><br><span class="line">toggleClass: 切换类名  jQuery元素.toggleClass(<span class="string">&quot;类名&quot;</span>)</span><br><span class="line">hasClass: 判断有没有类名  jQuery元素.hasClass(<span class="string">&quot;类名&quot;</span>)</span><br><span class="line"></span><br><span class="line">操作样式</span><br><span class="line">获取样式: jquery元素.css(<span class="string">&quot;样式属性名&quot;</span>)</span><br><span class="line">设置样式: jQuery元素.css(<span class="string">&quot;样式属性名&quot;</span>,<span class="string">&quot;属性值&quot;</span>)</span><br><span class="line">批量设置: jQuery元素.css(&#123;样式属性名:属性值,样式属性名:属性值,...&#125;)</span><br><span class="line">批量获取: jQuery元素.css([<span class="string">&quot;样式属性名1&quot;</span>,<span class="string">&quot;样式属性名2&quot;</span>,...])</span><br><span class="line"></span><br><span class="line">操作元素内容</span><br><span class="line">jQuery元素.html() 获取元素的html内容</span><br><span class="line">jQuery元素.html(<span class="string">&quot;内容&quot;</span>) 设置元素的html内容</span><br><span class="line">jQuery元素.text() 获取元素文本内容</span><br><span class="line">jQuery元素.text(<span class="string">&quot;内容&quot;</span>) 设置元素文本内容</span><br><span class="line">jQuery元素.val() 获取表单元素内容</span><br><span class="line">jQuery元素.val(<span class="string">&quot;内容&quot;</span>) 设置表单元素内容</span><br></pre></td></tr></table></figure><h2 id="jQuery的each方法-和-extend方法"><a href="#jQuery的each方法-和-extend方法" class="headerlink" title="jQuery的each方法 和 extend方法"></a>jQuery的each方法 和 extend方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.each</span><br><span class="line">$.each() </span><br><span class="line">  用法：$.each(要循环的数组或对象,function(idx,item)&#123;&#125;)</span><br><span class="line">  idx:如果循环的是数组 表示数组项下标 如果循环的是对象 表示对象的属性名</span><br><span class="line">  item: 如果循环的是数组 表示数组项  如果循环的是对象 表示对象的属性值</span><br><span class="line">  作用：可以循环任意数组或对象</span><br><span class="line">jQuery元素.each()</span><br><span class="line">  用法：jQuery元素.each(function(idx,item)&#123;&#125;)</span><br><span class="line">  作用：用来循环jQuery元素</span><br><span class="line">  idx: 表示jQuery元素中 每一个数组项的 下标</span><br><span class="line">  item: 表示jQuery元素中 的数组项</span><br><span class="line">2.extend</span><br><span class="line">  用法: $.extend(对象1，对象2，对象3，...)</span><br><span class="line">  作用: 可以将对象1后面的所有对象 合并到 对象1中 并将合并好的对象 返回出来</span><br><span class="line">  注意: 对象1后面的所有对象 都不会改变 但对象1 自身会改变</span><br><span class="line"></span><br><span class="line">  用法1: $.extend(&#123;&#125;,对象1，对象2，...)   推荐使用</span><br><span class="line">  这样就可以不改变 原来的对象了</span><br><span class="line"></span><br><span class="line">  用法2: $.extend(&#123;&#125;,obj) </span><br><span class="line">  作用:  克隆对象</span><br><span class="line">  注意：这种克隆 叫做浅克隆  克隆出来的对象 和 原对象 互相影响</span><br><span class="line"></span><br><span class="line">  如果我们不想互相影响 就需要执行 深克隆</span><br><span class="line">  用法3: $.extend(true,&#123;&#125;,obj)</span><br><span class="line">  作用 : 可以将obj深克隆下来 这样克隆出的对象 和 原对象 互不影响</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端原生js 和 touch</title>
      <link href="2021/05/04/18-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8E%9F%E7%94%9Fjs%20%E5%92%8C%20touch/"/>
      <url>2021/05/04/18-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8E%9F%E7%94%9Fjs%20%E5%92%8C%20touch/</url>
      
        <content type="html"><![CDATA[<h1 id="移动端原生js-和-touch"><a href="#移动端原生js-和-touch" class="headerlink" title="移动端原生js 和 touch"></a>移动端原生js 和 touch</h1><h2 id="移动端原生js"><a href="#移动端原生js" class="headerlink" title="移动端原生js"></a>移动端原生js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>移动端事件</span><br><span class="line"><span class="number">1.</span>touchstart 触摸开始事件  当用户手指触碰到添加事件的元素的瞬间 触发该事件  </span><br><span class="line"><span class="number">2.</span>touchend 触摸结束事件  当用户手指离开添加事件的元素的瞬间 触发该事件</span><br><span class="line"><span class="number">3.</span>touchmove 触摸移动事件  当用户手指按在添加事件的元素上 并移动的时候 触发该事件</span><br><span class="line"></span><br><span class="line">注意：在移动端中 我们 不考虑兼容问题。</span><br><span class="line">由于移动端效果 需要打开控制台 切换为移动端效果 因此在测试效果之前 需要先刷新一下。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>在移动端中存在的问题</span><br><span class="line"><span class="number">1.</span>PC端事件在移动端中 能否正常运行 : 不能</span><br><span class="line">  <span class="number">1.</span>pc端事件在移动端中 会延迟 300ms 执行</span><br><span class="line"><span class="number">2.</span>移动端的点透事件</span><br><span class="line">  <span class="number">1.</span>当一个div盖住a标签的时候 我们点击a标签正上方的div部分，让div隐藏，这时 这个手指触摸事件 就会穿透div 传递到下面的 a标签上。  如果点击时间超过700ms 就可以防止穿透</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>移动端事件的事件对象</span><br><span class="line">  移动端事件 在添加的时候 建议使用addEventListener添加， 因为on添加 可能会出现一些问题</span><br><span class="line">  获取事件对象：使用事件处理函数的第一个形参 接收事件对象</span><br><span class="line">  示例代码：元素.addEventListener(<span class="string">&quot;touchstart&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;event就可以接收到事件对象&#125;)</span><br><span class="line"></span><br><span class="line">  移动端事件对象独有的属性</span><br><span class="line">  <span class="number">1.</span>changedTouches : 记录当前触发事件的手指信息  一般我们更多使用这个属性</span><br><span class="line">  这个属性中 会记录 触发当前事件的所有手指 的信息。 是一个伪数组 每有一个手指 就添加一个对象类型  的数组项，记录手指的信息</span><br><span class="line">    手指相关重要信息</span><br><span class="line">    <span class="number">1.</span>clientX/Y  手指相对于可视窗口的位置</span><br><span class="line">    <span class="number">2.</span>pageX/Y  手指相对于页面内容的位置</span><br><span class="line">    <span class="number">3.</span>rotationAngle : 当前元素 旋转过的角度</span><br><span class="line">    <span class="number">4.</span>target : 实际触发事件的元素</span><br><span class="line">  <span class="number">2.</span>targetTouches : 记录当前元素上的手指信息</span><br><span class="line">  <span class="number">3.</span>touches : 记录当前整个屏幕上的手指信息</span><br><span class="line">  </span><br><span class="line">  使用移动端事件 及 事件对象 实现拖拽轮播图</span><br><span class="line">  思路：</span><br><span class="line">  <span class="number">1.</span>手指按下 并判断 当前按在了 哪一张图片上</span><br><span class="line">  <span class="number">2.</span>移动手指，让ul跟随手指进行移动</span><br><span class="line">  <span class="number">3.</span>松开手指，判断ul移动是否超过图片宽度的一半 如果超过 就切换图片  如果不超过 就回到原图</span><br></pre></td></tr></table></figure><h2 id="touch-了解"><a href="#touch-了解" class="headerlink" title="touch   了解"></a>touch   了解</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">touchjs</span><br><span class="line">touch是百度云团队 专门针对 移动端项目开发 设计的类库  大大的方便了 移动端的开发，主要体现在 事件绑定及各种事件上。</span><br><span class="line"></span><br><span class="line">touch.js在引入之后 会生成一个 touch对象 这个对象有很多方法 可以解决不同问题</span><br><span class="line"></span><br><span class="line">1.事件绑定 : </span><br><span class="line">  用法1 : touch.on(添加事件的元素,&quot;事件类型&quot;,function()&#123;&#125;);</span><br><span class="line">  用法2 : touch.on(添加事件的元素,&quot;事件类型1 事件类型2 ...&quot;,function()&#123;&#125;); </span><br><span class="line"> 作用：可以给元素 一次性绑定多个事件  所有事件 共用一个处理函数。</span><br><span class="line"> 优点：可以批量绑定事件</span><br><span class="line"> 缺点：大家共用一个处理函数 导致不够灵活</span><br><span class="line">  用法3 : touch.on(添加事件的元素,&#123;事件类型1:function()&#123;&#125;,事件类型2:function()&#123;&#125;,...&#125;);</span><br><span class="line">          优点：既可以批量绑定事件 又可以灵活执行效果</span><br><span class="line">2.事件委托 : </span><br><span class="line">  用法：touch.on(父元素,&quot;事件类型&quot;,子元素选择器,function()&#123;&#125;)</span><br><span class="line">  作用：将事件绑定给父元素  之后 当事件触发的时候 使用子元素选择器 判断是否是指定的子元素触发了事          件，如果是 就执行处理函数 如果不是 就啥也不做</span><br><span class="line">3.事件对象 :</span><br><span class="line">  touchjs的事件对象和普通原生移动端js事件的事件对象不同</span><br><span class="line">  例如touchjs的tap事件</span><br><span class="line">  获取事件对象的方法: touch.on(添加事件的元素,&quot;事件类型&quot;,function(形参)&#123; 形参可以接收到事件对象     &#125;)</span><br><span class="line">  事件对象中比较重要的属性</span><br><span class="line">  originEvent：当前touch事件 对应的原生事件 的事件对象</span><br><span class="line">  position: 当前触发事件的手指 相对于 可视窗口的位置信息</span><br><span class="line">  startRotate: 这个属性 值为一个函数  他是一个开关，如果想旋转元素 需要调用这个方法 打开开关，才能   旋转 如果不调用 没有旋转效果</span><br><span class="line">4.手势事件</span><br><span class="line">  触碰类事件：tap(轻触类事件) doubletap(双击事件) hold(长按事件)</span><br><span class="line">  动画执行完成事件 : animationend  这个事件 会在 css动画执行完的瞬间触发 </span><br><span class="line"></span><br><span class="line">  滑动类事件：swipestart滑动手势起点、swiping滑动中、swipeend滑动手势终点、swipeleft向左滑动、swiperight向右滑动、swipeup向上滑动、swipedown向下滑动、swipe滑动</span><br><span class="line"></span><br><span class="line">  拖拽类事件：dragstart拖动开始、drag拖动、dragend拖动结束</span><br><span class="line"></span><br><span class="line">  旋转类事件：rotateleft向左旋转、rotateright向右旋转、rotate旋转</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端浏览器缓存</title>
      <link href="2021/05/03/17-%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>2021/05/03/17-%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前端浏览器缓存"><a href="#前端浏览器缓存" class="headerlink" title="前端浏览器缓存"></a>前端浏览器缓存</h2><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">特点：1.缓存数据量小  4k左右</span><br><span class="line"> 2.缓存数据会随着 ajax数据交互在前后端之间传递</span><br><span class="line"> 3.缓存数据有有效期 有效期手动设置 一旦过了有效期 立刻清除缓存</span><br></pre></td></tr></table></figure><h2 id="localStorage-本地缓存"><a href="#localStorage-本地缓存" class="headerlink" title="localStorage  本地缓存"></a>localStorage  本地缓存</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">html5是三个方面的更新</span><br><span class="line">html方面：新增了 媒体标签  语义化标签等</span><br><span class="line">css方面：就是css3  新增了选择器 动画样式</span><br><span class="line">js方法：新增了 dom的一些新的API（方法） querySelector/querySelectorAll localStorage sessionStorage </span><br><span class="line">localStorage和sessionStorage都是h5新增的DOM方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">localStorage是一个对象</span><br><span class="line">这个对象可以通过属性 保存一些数据 从而实现前端缓存</span><br><span class="line">localStorage对象 的 原型中 存放着操作 localStorage的方法</span><br><span class="line">getItem : localStorage.getItem(&quot;属性名&quot;) 可以获取到指定属性名的缓存数据 </span><br><span class="line">setItem : localStorage.setItem(&quot;属性名&quot;,&quot;属性值&quot;) 可以向localStorage中存入指定数据</span><br><span class="line">removeItem : localStorage.removeIte(&quot;属性名&quot;)  可以删除缓存中指定的数据</span><br><span class="line">clear :localStorage.clear()   清空所有缓存数据</span><br><span class="line"></span><br><span class="line">localStorage特点</span><br><span class="line">1.缓存的数据量 较大 20M左右</span><br><span class="line">2.localStorage缓存的数据永远呆在前端</span><br><span class="line">3.localStorage有效期为永久。除非手动删除 否则永久缓存</span><br></pre></td></tr></table></figure><h2 id="sessionStorage-会话缓存"><a href="#sessionStorage-会话缓存" class="headerlink" title="sessionStorage  会话缓存"></a>sessionStorage  会话缓存</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage也是一个对象 和 localStorage一样</span><br><span class="line">操作方法 和 保存数据的方式 和 localStorage完全一样</span><br><span class="line"></span><br><span class="line">sessionStorage特点</span><br><span class="line">1.缓存数据量 较大 20M左右</span><br><span class="line">2.sessionStorage缓存的数据也会一直呆在前端 去不了后台</span><br><span class="line">3.sessionStorage缓存的数据 会在页面关闭的时候清除</span><br></pre></td></tr></table></figure><h2 id="注意：localStorage和sessionStorage在缓存数据的时候-都会将数据转换为字符串进行存储"><a href="#注意：localStorage和sessionStorage在缓存数据的时候-都会将数据转换为字符串进行存储" class="headerlink" title="注意：localStorage和sessionStorage在缓存数据的时候  都会将数据转换为字符串进行存储"></a>注意：localStorage和sessionStorage在缓存数据的时候  都会将数据转换为字符串进行存储</h2>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax收尾</title>
      <link href="2021/05/03/16-ajax%E6%94%B6%E5%B0%BE/"/>
      <url>2021/05/03/16-ajax%E6%94%B6%E5%B0%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="ajax收尾"><a href="#ajax收尾" class="headerlink" title="ajax收尾"></a>ajax收尾</h1><h2 id="1-ajax操作数组"><a href="#1-ajax操作数组" class="headerlink" title="1.ajax操作数组"></a>1.ajax操作数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>方法可以帮助我们操作数组</span><br><span class="line">我们请求到的数据 如果是一个 数组字符串 为了方便操作 我们一般会将这个字符串转换为数组  转换可以使用<span class="built_in">eval</span>方法</span><br><span class="line">用法：<span class="built_in">eval</span>(要转换的字符串)</span><br><span class="line">作用：<span class="built_in">eval</span>这个方法 可以将 传入其中的 字符串里面的 js代码 自动执行</span><br></pre></td></tr></table></figure><h2 id="2-ajax操作json"><a href="#2-ajax操作json" class="headerlink" title="2.ajax操作json"></a>2.ajax操作json</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">最开始 开发者在项目中普遍使用的数据交互格式 为 XML</span><br><span class="line">XML有很大的局限性  体现在</span><br><span class="line"><span class="number">1.</span>数据结构依然相对复杂，不利于网络传输</span><br><span class="line"><span class="number">2.</span>响应到前端的XML数据 操作起来也不方便</span><br><span class="line"></span><br><span class="line">后来出现了 json数据格式  json不是任何一门语言  只是一种单纯的数据类型</span><br><span class="line">json的优点  体现在</span><br><span class="line"><span class="number">1.</span>json是一种单纯的数据结构 因此数据量可以极大降低 利于网络传输</span><br><span class="line"><span class="number">2.</span>json数据的数据格式很简单 响应到前端的数据 很方便操作</span><br><span class="line"></span><br><span class="line">json的写法 : </span><br><span class="line"><span class="number">1.</span>json数据 其实就是 后缀名为 .json 的文件</span><br><span class="line"><span class="number">2.</span>一个json文件中 只能写一条数据 因此我们在json中 一般都会写入数组或对象</span><br><span class="line"><span class="number">3.</span>json文件中不能写注释</span><br><span class="line">json数组的注意事项 : </span><br><span class="line"><span class="number">1.</span>json数组中的最后一项后面不能加逗号</span><br><span class="line">json对象的注意事项</span><br><span class="line"><span class="number">1.</span>属性名必须加引号 且在json文件中 引号只能使用双引号 不能用单引号</span><br><span class="line"><span class="number">2.</span>json对象的最后一个属性 后面不能加逗号</span><br><span class="line"></span><br><span class="line">我们获取到的json数据 都是一个字符串 如果想得到真正的数据 可以使用json的专属转换方法</span><br><span class="line">将json字符串转换为js数据：<span class="built_in">JSON</span>.parse(要转换的json字符串)</span><br><span class="line">将js数据转换为json字符串：<span class="built_in">JSON</span>.stringify(要转换的js数据)</span><br></pre></td></tr></table></figure><h2 id="项目细节问题"><a href="#项目细节问题" class="headerlink" title="项目细节问题"></a>项目细节问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在项目中 使用link的href属性引入css  script的src属性引入js</span><br><span class="line">href和src属性的区别</span><br><span class="line">href : 将当前html文件中的任务 交给外部文件去做（任务委派） </span><br><span class="line">src : 将外部文件 引入到 当前的html文件中 完成指定任务 (资源引入)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名函数，闭包和ajax</title>
      <link href="2021/05/03/15-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%8C%E9%97%AD%E5%8C%85%E5%92%8Cajax/"/>
      <url>2021/05/03/15-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%8C%E9%97%AD%E5%8C%85%E5%92%8Cajax/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名函数，闭包和ajax"><a href="#匿名函数，闭包和ajax" class="headerlink" title="匿名函数，闭包和ajax"></a>匿名函数，闭包和ajax</h1><h2 id="匿名函数-熟练运用"><a href="#匿名函数-熟练运用" class="headerlink" title="匿名函数    熟练运用"></a>匿名函数    熟练运用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">定义 : 匿名函数 就是 没有函数名的 函数</span><br><span class="line">例如 : <span class="keyword">var</span> 变量名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,时间间隔)</span><br><span class="line">  元素.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">匿名函数的自执行</span><br><span class="line"><span class="number">1.</span>匿名函数的声明:</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;我是匿名函数&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="number">2.</span>匿名函数的调用:</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;我是匿名函数&quot;</span>);</span><br><span class="line">        &#125;)();</span><br><span class="line">匿名函数的参数和返回值</span><br><span class="line"><span class="number">1.</span>匿名函数的形参 也写在 函数声明小括号中 实参写在 函数调用小括号中</span><br><span class="line"><span class="number">2.</span>匿名函数的返回值 也写在 函数中 用<span class="keyword">return</span> 返回</span><br><span class="line"><span class="keyword">var</span> ret = (<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;我是匿名函数1&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(a,b);<span class="comment">//10,20</span></span><br><span class="line">            <span class="keyword">return</span> a+b;<span class="comment">//30</span></span><br><span class="line">        &#125;)(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(ret);</span><br><span class="line">匿名函数的优点</span><br><span class="line"><span class="number">1.</span>匿名函数 和 普通的函数 不同  在不调用的时候 匿名函数不会存储到内存中，什么时候调用 什么时候存入内存，调用执行完之后 还会将匿名函数从内存中清除掉  因此可以在最大限度节省内存</span><br><span class="line">因此我们也推荐大家使用匿名函数</span><br><span class="line"></span><br><span class="line">总结：到目前为止 我们已经学过的函数</span><br><span class="line">普通函数  事件处理函数 对象的方法函数 构造函数 递归函数 回调函数(函数类型的实参) 匿名函数</span><br></pre></td></tr></table></figure><h2 id="闭包函数-熟练运用"><a href="#闭包函数-熟练运用" class="headerlink" title="闭包函数   熟练运用"></a>闭包函数   熟练运用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义 : 闭包就是能够读取其他函数内部变量的函数（函数里面套函数，内部函数访问外部函数变量），在本质上，闭包是将函数内部和函数外部连接起来的桥梁。  </span><br><span class="line"><span class="number">2.</span>实例 : </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        a++</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当内层函数 访问 外层函数形参 也是闭包结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        a++</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>闭包的特点 : 在闭包的外层函数中声明的变量，会一直存储在内存中，类似全局变量,避免了全局污染。</span><br><span class="line">一般的局部变量 会在函数执行的时候 存入内存中  函数执行完 就从内存中清理掉</span><br><span class="line">闭包函数 外层函数中声明的变量 则可以永久的保留在内存中 类似于全局变量</span><br><span class="line"></span><br><span class="line">全局污染：全局变量会作为<span class="built_in">window</span>对象的属性和方法存在  如果声明的过多 会导致<span class="built_in">window</span>对象的属性和方法过于  冗余，这就是全局污染</span><br><span class="line"><span class="number">1.</span>闭包的优点：可以永久保留变量 又 避免了全局污染</span><br><span class="line"><span class="number">2.</span>闭包的缺点：由于变量永久保存 因此如果闭包函数太多 会导致存储的变量过多 进而导致内存溢出</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>闭包解决的实际问题</span><br><span class="line"><span class="number">1.</span>解决<span class="keyword">for</span>循环嵌套事件的问题</span><br><span class="line"><span class="number">2.</span>闭包可以模拟私有属性 </span><br><span class="line">  在java c 等强类型语言中  对象的属性 存在两类  分别是   </span><br><span class="line">  私有属性(private):这种属性 一般用来记录一些比较核心的数据 这种属性不能随意访问和修改，如果想访问和修改 需要使用对象提供的专门方法 来进行操作</span><br><span class="line">  公有属性(public):这种属性和js中对象的属性类似 可以随意访问</span><br><span class="line">  在js中没有私有属性的概念 因此 只能拿闭包来模拟</span><br><span class="line"><span class="number">5.</span>js代码的执行顺序总结</span><br><span class="line">  <span class="number">1.</span>预解析 在js代码执行之前 将 函数声明 和 变量声明 提升到作用域最顶端</span><br><span class="line">  <span class="number">2.</span>从上到下执行js代码</span><br><span class="line">  <span class="number">3.</span>如果中途 遇到 异步代码 需要先存入任务队列 之后 继续向下执行代码。</span><br><span class="line">  <span class="number">4.</span>待所有代码都执行完后 从任务队列中 取出先前存放的异步代码 按照顺序依次执行</span><br></pre></td></tr></table></figure><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>ajax : Async javascript and XML</span><br><span class="line">       异步的    js      和  XML</span><br><span class="line">ajax主要用来实现 前后端分离的 web端项目</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>ajax代码的编写流程</span><br><span class="line">  <span class="number">1.</span>创建ajax对象</span><br><span class="line">  <span class="number">2.</span>调用ajax对象的open方法 建立和后台之间的链接</span><br><span class="line">  <span class="number">3.</span>调用ajax对象的send方法 发送请求</span><br><span class="line">  <span class="number">4.</span>给ajax对象 添加onreadystatechange事件  监测通信状态码 如果值为<span class="number">4</span> 证明可以获取数据</span><br><span class="line">  <span class="number">5.</span>判断ajax对象的 响应状态码 是不是<span class="number">200</span> 或 <span class="number">304</span> 如果是 就可以获取数据  如果不是 不能获取数据</span><br><span class="line"></span><br><span class="line">wamp的www文件夹中 应尽量避免出现文件名为index的文件 因为浏览器 会默认打开 www文件夹中的index文件</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>ajax常用的请求方式</span><br><span class="line"><span class="number">1.</span>get:</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="comment">//ajax提交数据 get请求方式 是在url地址后面写提交的数据</span></span><br><span class="line">        <span class="comment">//url地址?键名=键值&amp;键名=键值....</span></span><br><span class="line">        xhr.open(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;./data.txt?userName=狗蛋&amp;hobby=吃&amp;age=3&quot;</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status==<span class="number">200</span>||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">get请求的优点: 请求和响应速度比较快</span><br><span class="line">get请求的缺点: <span class="number">1.</span>请求提交的数据 会直接跟在地址后面 导致信息的泄露</span><br><span class="line">     <span class="number">2.</span>提交数据的数据量 最大为4k</span><br><span class="line"><span class="number">2.</span>post:</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;post&#x27;</span>,<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//post需要设置 请求的 请求头  设置请求头 作用是用来 拓容， 让post请求可以提交更多的数据  最多可以提交20M数据</span></span><br><span class="line">        <span class="comment">//报文（数据包）</span></span><br><span class="line">        <span class="comment">//请求报文  响应报文</span></span><br><span class="line">        <span class="comment">//请求报文分为三块 请求命令行 请求头 请求主体</span></span><br><span class="line">        <span class="comment">//设置请求头 使用ajax对象的 setRequestHeader方法</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        <span class="comment">//post请求是在send方法中提交数据的</span></span><br><span class="line">        <span class="comment">//写法：xhr.send(&quot;键名=键值&amp;键名=键值。。。&quot;)</span></span><br><span class="line">        xhr.send(<span class="string">&quot;userName=张三丰&amp;age=18&amp;lover=郭襄&quot;</span>);</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.status==<span class="number">200</span>||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">post请求方式的优点: <span class="number">1.</span>提交的数据量可以扩充到20M</span><br><span class="line"> <span class="number">2.</span>数据安全性高 提交的数据 不会显示在地址后面</span><br><span class="line">post请求方式的缺点: 请求响应的速度稍慢</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="2021/05/03/14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/05/03/14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="面向对象继承方式"><a href="#面向对象继承方式" class="headerlink" title="面向对象继承方式"></a>面向对象继承方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>原型链继承</span><br><span class="line">  原型链 : 每一个对象都有原型，通过__proto__属性可以得到原型。 原型也是对象 因此原型对象也有原型。   像这样，由__proto__属性 链接起来了一个 链式结构  这个链式结构就是原型链</span><br><span class="line">  原型链的起点和终点 : 起点就是实例对象  终点是<span class="built_in">Object</span>.prototype</span><br><span class="line">  原型链有多少级 : 原型链最多不超过三级</span><br><span class="line">  </span><br><span class="line">  强调 : 原型链中的所有属性 实例对象都可以使用</span><br><span class="line">  </span><br><span class="line">  原型链继承：一个构造函数 想让自己创建的实例对象 可以继承到已存在的原型链中的属性  只需要让构造函数     和原型链 产生关联即可</span><br><span class="line">  优点：可以继承到原型链中的属性和方法</span><br><span class="line">  缺点：不能修改继承来的属性</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span>对象冒充式继承</span><br><span class="line">  call和apply</span><br><span class="line">  这是两种 函数对象 的 专属方法  作用相同  是用来改变函数的<span class="built_in">this</span>指向的</span><br><span class="line">  call</span><br><span class="line">  用法 : 函数.call(改变后的<span class="built_in">this</span>指向,原函数需要的实参<span class="number">1</span>,实参<span class="number">2</span>,...) </span><br><span class="line">  作用 : 先改变函数的<span class="built_in">this</span>指向为指定值 之后 立即调用函数 调用的时候 传入原函数需要的实参</span><br><span class="line">  apply</span><br><span class="line">  用法 : 函数.apply(改变后的<span class="built_in">this</span>指向,[原函数需要的实参<span class="number">1</span>,实参<span class="number">2</span>,...])</span><br><span class="line">  作用 : 和call完全一样</span><br><span class="line">  </span><br><span class="line">  对象冒充继承</span><br><span class="line">  优点：可以随意改变创建的实例对象的属性值</span><br><span class="line">  缺点：得不到原型链中的属性</span><br><span class="line"><span class="number">3.</span>组合式继承</span><br><span class="line">  把对象冒充继承 和 原型链继承 组合起来使用 就是 组合式继承</span><br><span class="line">  优点：既可以通过 对象冒充继承 灵活改变属性值 又可以继承到原型链中的属性</span><br><span class="line">  缺点：</span><br><span class="line"><span class="number">4.</span>寄生组合式继承</span><br></pre></td></tr></table></figure><p>原型链继承示意图</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Administrator\Desktop\原型链继承.png" alt="原型链继承"></p><h2 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>正则表达式的定义 : </span><br><span class="line">正则表达式 是对字符串操作的一种逻辑公式，就是用事先定义好的一些特殊字符，及这些特定字符的组合，组成一个‘规则字符串’，这个规则字符串用来表达对字符串的一种过滤逻辑</span><br><span class="line">正则表达式的写法：</span><br><span class="line"><span class="number">1.</span>字面量声明 : <span class="keyword">var</span> reg = <span class="regexp">/正则内容/</span>修饰符;</span><br><span class="line"><span class="number">2.</span>实例化创建 : <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;正则内容&quot;</span>,<span class="string">&quot;修饰符&quot;</span>);</span><br><span class="line"></span><br><span class="line">正则的匹配只匹配成功一次  第一次匹配成功之后 就不继续向后匹配了。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>正则表达式的编写方式</span><br><span class="line"><span class="number">1.</span>字面量声明 : <span class="keyword">var</span> reg = <span class="regexp">/正则内容/</span>修饰符;</span><br><span class="line"><span class="number">2.</span>实例化创建 : <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;正则内容&quot;</span>,<span class="string">&quot;修饰符&quot;</span>);</span><br><span class="line"></span><br><span class="line">修饰符 : 修饰符就是正则表达式中 用来指定某些特定匹配规则的</span><br><span class="line">    g(<span class="built_in">global</span>全局的) : 加上g修饰符的正则表达式要求必须从字符串开头一直匹配到结尾</span><br><span class="line">    i(ignoreCase忽略大小写) : 加上i修饰符的正则表达式 在匹配的时候 不区分大小写</span><br><span class="line"><span class="number">3.</span>正则的检索方法</span><br><span class="line">正则表达式的方法</span><br><span class="line">    <span class="number">1.</span>test : 正则表达式.test(要检索的字符串); 可以检索字符串</span><br><span class="line">    <span class="number">2.</span>exec : 正则表达式.exec(要检索的字符串); 可以检索字符串</span><br><span class="line">        test作用: test会按照正则标准 检索指定的字符串 如果检索成功(指定字符串中包含正则要求的部分)  返回<span class="literal">true</span>  检索失败返回<span class="literal">false</span></span><br><span class="line">        exec作用: exec会按照正则标准 检索指定字符串 如果检索成功 返回一个数组 检索失败 返回<span class="literal">null</span></span><br><span class="line">字符串对象的方法</span><br><span class="line">    <span class="number">1.</span>replace : 字符串.replace(正则表达式,用来替换的字符片段);</span><br><span class="line"> 作用:使用用来替换的字符片段，替换掉正则表达式匹配到的字符片段</span><br><span class="line">    <span class="number">2.</span>split : 字符串.split(正则表达式)</span><br><span class="line"> 作用:使用正则表达式匹配到的字符 作为 切割标识 对字符串进行切割</span><br><span class="line">         <span class="number">3.</span>match : 字符串.match(正则表达式)</span><br><span class="line"> 作用 : 和正则表达式的exec作用完全相同</span><br><span class="line">         <span class="number">4.</span>search : 字符串.search(正则表达式);</span><br><span class="line"> 作用 : 如果检索成功 返回 第一次检索到的下标 如果检索失败 返回 -<span class="number">1</span></span><br><span class="line"><span class="number">4.</span>正则表达式的元字符</span><br><span class="line">正则定义中 说的 特殊字符 和 特定字符的组合 就是正则的元字符</span><br><span class="line">    <span class="number">1.</span> .代表要匹配 除了换行符之外的 其他字符 /./ 匹配换行符之外的其他字符</span><br><span class="line">    <span class="number">2.</span>[a-z0-<span class="number">9</span>] 表示要匹配a-z <span class="number">0</span>-<span class="number">9</span> 之间的所有小写字母和 数字  中括号中写的是匹配范围</span><br><span class="line">    <span class="number">3.</span>[^a-z0-<span class="number">9</span>] 表示要匹配 除了 a-z <span class="number">0</span>-<span class="number">9</span>之间的所有大写字母和特殊字符  [^] 表示要匹配指定范围之外的  字符</span><br><span class="line">    <span class="number">4.</span>\d  \D  \d表示匹配数字 就相当于[<span class="number">0</span>-<span class="number">9</span>]   \D匹配非数字</span><br><span class="line">    <span class="number">5.</span>\w  \W  \w表示匹配 字母数字下划线      \W匹配非数字非字母非下划线</span><br><span class="line">    <span class="number">6.</span>\s  \S  \s表示匹配 空白字符(空格、\n、\t)  \S匹配非空白字符</span><br><span class="line">    <span class="number">7.</span>\b  \B  \b表示匹配字符边界    \B表示匹配非字符边界                                         <span class="number">8.</span> ^   $  ^表示匹配开头        $表示匹配结尾  </span><br><span class="line">    正则的严格模式 /^正则内容$/  表示要求检索的字符串内容 和 正则内容完全相同 多了也不可以 少了也不 可以</span><br><span class="line"><span class="number">5.</span>正则表达式的量词</span><br><span class="line">?  <span class="regexp">/^\d?$/</span> 在正则表达式中 ？ 表示前面的内容出现 <span class="number">0</span>次 或 <span class="number">1</span>次  这个正则 表示匹配空字符串 或 一位数字的字符串</span><br><span class="line">    + <span class="regexp">/^\d+$/</span>  在正则表达式中 + 表示前面的内容 出现 至少<span class="number">1</span>次 多了不限</span><br><span class="line">    * <span class="regexp">/^\d*$/</span>  在正则表达式中 * 表示前面的内容 出现任意多次</span><br><span class="line">    &#123;&#125; /^\d&#123;n&#125;$/  在正则表达式中 &#123;n&#125;表示前面的内容 出现n次  既不能多 也不能少</span><br><span class="line">&#123;&#125; /^\d&#123;n,m&#125;$/  在正则表达式中 &#123;n,m&#125;表示前面的内容 出现至少n次 至多m次 既不能多 也不能少</span><br><span class="line"><span class="number">6.</span>正则表达式其他用法</span><br><span class="line"><span class="number">1.</span>或运算</span><br><span class="line">    写法: <span class="regexp">/a | b | c/</span>  或运算代表的意思是正则表达式可以匹配a或b或c</span><br><span class="line"><span class="number">2.</span>分组</span><br><span class="line">    分组就是使用() 把一些内容包裹起来 从而让包裹起来的内容 组成一个整体</span><br><span class="line">    在正则匹配过程中 会先匹配整个正则表达式 匹配完之后 如果有分组 我们还会拿每一个分组单独进行匹配。</span><br><span class="line">    <span class="comment">//我们可以 直接获取 分组单独匹配得到的结果</span></span><br><span class="line">    <span class="comment">//获取方式是  RegExp.$n   n表示第n个分组</span></span><br><span class="line">    强调 : 在获取分组单独匹配到的结果之前 要先对正则表达式进行匹配</span><br><span class="line">    </span><br><span class="line">    在使用字符串的replace方法进行正则验证的时候 可以简写 获取分组单独匹配结果 写法如下</span><br><span class="line">    str.replace(<span class="regexp">/正则内容/</span>,<span class="string">&quot;$1,$2,...&quot;</span>)</span><br><span class="line"><span class="comment">//在这里 $1表示第一个分组匹配的结果  $2表示第二个分组匹配到的结果 ....</span></span><br><span class="line"><span class="number">3.</span>前瞻后顾</span><br><span class="line">    前瞻:exp1(?=exp2) 作用:要求匹配后面是exp2的exp1  例如</span><br><span class="line">    /张三(?=李四)/ 作用:要求匹配 后面跟着李四的张三</span><br><span class="line">    负前瞻:exp1(?!exp2) 作用:要求匹配后面不是exp2的exp1 例如</span><br><span class="line">        /张三(?!李四)/ 作用:要求匹配 后面跟的不是李四的张三</span><br><span class="line">    后顾:(?&lt;=exp2)exp1 作用:要求匹配前面是exp2的exp1 </span><br><span class="line">    负后顾:(?&lt;!exp2)exp1 作用:要求匹配前面不是exp2的exp1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2021/05/03/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/05/03/13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">面向对象概念 : 使用对象时，只关注对象提供的功能，不关注其内部细节。</span><br><span class="line">面向对象是一种 编程思想  是相对于 面向过程思想存在的</span><br><span class="line">面向对象思想 就是 有对象就用对象  没有对象 就创建对象 并用对象</span><br><span class="line"></span><br><span class="line">面向对象的基本特征</span><br><span class="line">封装 : 把一些功能 写入对象中 封装起来 从而实现提升代码安全性 和 稳定性的目的 </span><br><span class="line">继承 : 对象 可以通过 很多种方式 从其他对象或函数中 继承属性 从而实现节省内存</span><br><span class="line">多态 : 同一操作 在 不同情况下 得到的结果不同  例如js中的 + </span><br><span class="line">       <span class="number">10</span> + <span class="number">10</span> == <span class="number">20</span></span><br><span class="line">       <span class="string">&quot;10&quot;</span> + <span class="number">10</span> == <span class="string">&quot;1010&quot;</span>;  </span><br></pre></td></tr></table></figure><h2 id="创建对象的方法图"><a href="#创建对象的方法图" class="headerlink" title="创建对象的方法图"></a>创建对象的方法图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>字面量创建</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    属性名:属性值,...</span><br><span class="line">&#125;</span><br><span class="line">优点 : 创建对象简单 直观</span><br><span class="line">缺点 : 不利于批量创建</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>实例化创建</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">//得到的结果是一个空对象</span></span><br><span class="line">obj1.属性名 = 属性值;....</span><br><span class="line">优点 : 创建的对象 类型更清晰</span><br><span class="line">缺点 : 不利于批量创建</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>工厂模式创建对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fac</span> (<span class="params">属性值参数,..</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">//创建一个空对象</span></span><br><span class="line">    <span class="comment">//给对象绑定属性</span></span><br><span class="line">    obj.属性名 = 属性值参数....</span><br><span class="line">    <span class="comment">//返回绑定好属性的对象</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line">优点 : 利于批量创建对象</span><br><span class="line">缺点 : 创建出的对象类型不明确</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>构造函数创建对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params">属性值形参,...</span>)</span>&#123; <span class="comment">//构造函数命名 首字母大写</span></span><br><span class="line">    <span class="comment">//1.js隐式创建空对象  obj &#123;&#125;</span></span><br><span class="line">    <span class="comment">//2.构造函数this---&gt; &#123;&#125;    这时 构造函数的this 就是 &#123;&#125;</span></span><br><span class="line">    <span class="comment">//3.通过this 给 空对象绑定属性和方法</span></span><br><span class="line">    <span class="comment">//构造函数通过其函数内部的this 给创建出的对象 绑定属性</span></span><br><span class="line">    <span class="built_in">this</span>.属性名 = 属性值形参...</span><br><span class="line">    <span class="comment">//4.js隐式返回 绑定好属性的 对象</span></span><br><span class="line">&#125;</span><br><span class="line">说明 : 在js中 构造函数 就是 类型  我们可以利用 构造函数(类型)  来 创建 实例对象</span><br><span class="line">创建实例对象的方法 : <span class="keyword">var</span> 实例对象 = <span class="keyword">new</span> 构造函数()</span><br><span class="line">构造函数创建对象的流程（<span class="keyword">new</span>关键字干了什么）</span><br><span class="line"><span class="number">1.</span>js隐式创建空对象</span><br><span class="line"><span class="number">2.</span>js隐式将 构造函数的 <span class="built_in">this</span> 指向 空对象</span><br><span class="line"><span class="number">3.</span>执行构造函数中的代码 (通过<span class="built_in">this</span> 给 空对象绑定属性和方法)</span><br><span class="line"><span class="number">4.</span>js隐式返回 绑定好属性的 对象</span><br><span class="line">优点 : 类型明确 利于批量创建</span><br><span class="line">缺点 : 如果存在属性值不变的属性 创建实例对象 就会导致内存浪费</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>原型创建对象</span><br><span class="line">原型的概念 : 每一个对象 都拥有一个自己的原型  原型也是对象  在原型对象中 包含的属性和方法 对象都可以用</span><br><span class="line">获取对象原型的属性 : 对象.__proto__   是一个非标准属性（在ECMAScript标准中 未收录的属性）  这个属性在各大浏览器中 没有兼容性问题</span><br><span class="line">获取实例对象原型的标准属性 : 构造函数.prototype  是一个标准属性</span><br><span class="line"></span><br><span class="line">原型 也可以 获取到 其对应的 构造函数(类型)</span><br><span class="line">原型.constructor ===&gt; 其对应的构造函数</span><br><span class="line">    </span><br><span class="line">总结:原型对象.constructor === 构造函数</span><br><span class="line">     构造函数.prototype === 原型对象</span><br><span class="line">     实例对象.__proto__ === 原型对象</span><br><span class="line">    原型对象中 所有 属性和方法 实例对象都可以使用 但不拥有 </span><br><span class="line">原型创建对象</span><br><span class="line">在构造函数中不给对象绑定任何属性 将要绑定给对象的属性 全部写在构造函数对应的原型中，这样 构造函数创建的实例对象 就是一个空对象，但是由于原型中 有属性 所以 实例对象可以使用原型中的属性和方法</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype.属性名 = 属性值...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Fn();<span class="comment">//由于构造函数没有给实例对象绑定任何属性 因此这时实例对象obj是一个空对象</span></span><br><span class="line"><span class="comment">//但是 写在原型对象Fn.prototype中的属性  实例对象obj都可以使用</span></span><br><span class="line">优点 : 最大限度节省了内存 因为属性只在原型中存储一次 所有的实例对象共用</span><br><span class="line">缺点 : 一荣俱荣，一损俱损  原型对象中的属性和方法 根本不能改变  因为一旦改变 所有实例对象在使用的时候都会发生变化</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>动态混合模式</span><br><span class="line">构造函数创建对象 可以灵活的修改属性值  但是 遇到值不变的属性  会产生内存的浪费</span><br><span class="line">原型创建对象 可以防止内存的浪费 但是 不能灵活修改属性值</span><br><span class="line">我们可以将 构造函数创建对象 和 原型创建对象 混合使用  这 就是 动态混合模式</span><br><span class="line"></span><br><span class="line">动态混合模式创建对象</span><br><span class="line"><span class="number">1.</span>将比较容易发生变化的属性 交给构造函数 绑定给对象</span><br><span class="line"><span class="number">2.</span>将不太容易发生变化的属性 交给原型对象 让实例对象可以使用 </span><br><span class="line">这样就 既可以灵活操作对象 又可以 最大限度上 节省内存</span><br><span class="line"></span><br><span class="line">推荐大家是使用动态混合模式 创建对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="面向对象实例"><a href="#面向对象实例" class="headerlink" title="面向对象实例"></a>面向对象实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="面向对象继承"><a href="#面向对象继承" class="headerlink" title="面向对象继承"></a>面向对象继承</h2>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 特效动画</title>
      <link href="2021/05/03/12-js%20%E7%89%B9%E6%95%88%E5%8A%A8%E7%94%BB/"/>
      <url>2021/05/03/12-js%20%E7%89%B9%E6%95%88%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="js-特效动画"><a href="#js-特效动画" class="headerlink" title="js 特效动画"></a>js 特效动画</h1><h2 id="拖拽效果"><a href="#拖拽效果" class="headerlink" title="拖拽效果"></a>拖拽效果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>鼠标 按住 要拖拽的元素</span><br><span class="line"><span class="number">2.</span>鼠标移动 让 要拖拽的元素 跟随鼠标移动</span><br><span class="line"><span class="number">3.</span>鼠标抬起 让 要拖拽的元素停止移动</span><br><span class="line"></span><br><span class="line">拖拽效果的默认行为</span><br><span class="line">如果我们拖拽图片 浏览器会默认 执行保存图片的效果</span><br><span class="line">如果我们拖拽选中文本  浏览器会默认 执行拖拽文本的效果</span><br><span class="line">在标准浏览器中 我们只需要给 鼠标按下事件 添加<span class="keyword">return</span> <span class="literal">false</span> 阻止默认行为 即可实现</span><br><span class="line"></span><br><span class="line">在IE中如果想阻止拖拽的默认行为 需要使用到 全局捕获</span><br><span class="line">setCapture  设置全局捕获</span><br><span class="line">用法 : 元素.setCapture()</span><br><span class="line">作用 : 只要给元素添加了 setCapture 不管在页面任何位置触发事件  只要触发了该元素具备的事件， 都会被该元素 捕获过来 执行对应的处理函数</span><br><span class="line">例如 : 给元素添加了点击事件  不管点击 页面上任何位置  都会执行元素的点击事件</span><br><span class="line">releaseCapture  释放全局捕获</span><br><span class="line">用法 : 元素.releaseCapture()</span><br><span class="line">作用 : 给元素调用releaseCapture 就是将元素的全局捕获释放掉 下一次就可以重新捕获了</span><br></pre></td></tr></table></figure><h2 id="封装缓冲动画函数"><a href="#封装缓冲动画函数" class="headerlink" title="封装缓冲动画函数"></a>封装缓冲动画函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">缓冲动画 就是  起步速度较快  之后速度逐渐降低直至到达终点速度降为<span class="number">0</span></span><br><span class="line">缓冲动画需要改变元素运动的速度 （速度不断减小）</span><br><span class="line">手段有两种</span><br><span class="line"><span class="number">1.</span>减小步频</span><br><span class="line"><span class="number">2.</span>减小步长 我们将步长设置为  (终点值-起点值)/<span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回调函数</span><br><span class="line">当把函数a  作为 函数b的实参 传入函数b时  就称函数a为回调函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params">x</span>)</span>&#123;&#125;</span><br><span class="line">b(a);</span><br></pre></td></tr></table></figure><h2 id="使用缓冲动画函数实现轮播图"><a href="#使用缓冲动画函数实现轮播图" class="headerlink" title="使用缓冲动画函数实现轮播图"></a>使用缓冲动画函数实现轮播图</h2>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件高级</title>
      <link href="2021/05/03/11-%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
      <url>2021/05/03/11-%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h1><p>onresize : 屏幕大小改变事件   当屏幕大小发生变化的时候  就会触发这个事件</p><p>​                onresize 事件 就是 一阶段学习的 媒体查询的 底层原理</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义 : 事件对象就是 一个 用来记录 事件相关信息的 对象</span><br><span class="line">获取事件对象的方法 : 在事件处理函数中 写入<span class="built_in">window</span>.event即可得到事件对象 (谷歌和IE中的用法)</span><br><span class="line">事件对象的重要属性</span><br><span class="line"><span class="number">1.</span> clientX/clientY : 获取当前鼠标 相对于 屏幕左侧 和 顶部 的 距离</span><br><span class="line"><span class="number">2.</span>pageX/pageY : 获取当前鼠标 相对于 页面左侧 和 顶部 的 距离</span><br><span class="line"><span class="number">3.</span>target/srcElement(IE中使用的兼容写法) : 获取添加当前事件 的 元素对象</span><br><span class="line"><span class="number">4.</span>type : 事件类型（事件名）</span><br><span class="line"><span class="number">5.</span>altKey/ctrlKey/shiftKey : 这三个属性 用来判断 用户在触发事件的时候 是否按住了alt/ctrl/shift键  如果按住了 值为<span class="literal">true</span>  没按住 值为<span class="literal">false</span>   主要用来做快捷键</span><br><span class="line"></span><br><span class="line">事件对象的兼容</span><br><span class="line">在谷歌和ie中 都可以使用<span class="built_in">window</span>.event(<span class="built_in">window</span>可以省略) 来获取事件对象  但在低版本火狐中直接使用event会报错。<span class="built_in">window</span>.event不会报错 但也得不到结果(<span class="literal">undefined</span>)   火狐中的写法为  在事件处理函数中 写入一个形参 该形参可以接收到 事件对象</span><br><span class="line">示例 : 元素.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">形参</span>)</span>&#123;</span><br><span class="line">    这里写入的形参 就可以接收到 事件对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">事件对象的兼容 : </span><br><span class="line">元素.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">形参</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> 事件对象 = <span class="built_in">window</span>.event || 形参;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">on方式添加事件 存在弊端  不能给同一元素 添加多个 同类事件  会覆盖</span><br><span class="line">但是 事件绑定可以</span><br><span class="line">用法 :</span><br><span class="line">标准浏览器 : 元素.addEventListener(<span class="string">&quot;事件类型&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,是否执行捕获);</span><br><span class="line">注意 : 是否执行捕获 可以不传  但事件类型  和  事件处理函数  必须传</span><br><span class="line">IE低版本浏览器 : 元素.attachEvent(<span class="string">&quot;on事件类型&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">事件绑定的兼容</span><br><span class="line">由于 元素.addEventListener 在标准浏览器中 值为函数 在IE中 值为<span class="literal">undefined</span>  因此 可以通过这一点 来判断所处的浏览器</span><br><span class="line"><span class="keyword">if</span>(元素.addEventListener==<span class="literal">undefined</span>)&#123;</span><br><span class="line">   <span class="comment">//证明在IE中  就使用 元素.attachEvent()...</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//证明在标准浏览器中  使用  元素.addEventListener()...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="DOM事件流-熟练应用"><a href="#DOM事件流-熟练应用" class="headerlink" title="DOM事件流       熟练应用"></a>DOM事件流       熟练应用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在js中 事件的执行 存在一个流程  这个流程 被称为 DOM事件流</span><br><span class="line">事件捕获阶段 : 在事件触发之后 浏览器 会将事件 从<span class="built_in">window</span>开始 向 子元素进行逐级传递  <span class="built_in">window</span>--&gt;<span class="built_in">document</span>--&gt;body--&gt;子元素  一直传递到 实际触发事件的元素身上  这个流程 就是事件捕获</span><br><span class="line">注意 : 在事件捕获的过程中 如果 某一级元素 和 实际出发事件的元素 有同类事件 也会一并触发</span><br><span class="line">确定目标阶段 : 找到了实际触发事件的元素 并 执行事件处理函数</span><br><span class="line">事件冒泡阶段 : 从实际触发事件的元素开始 向 <span class="built_in">window</span> 进行事件的传递， 逐级传递的过程中，如果某一元素也有同类事件 也会一并触发</span><br><span class="line">注意 : 浏览器默认执行冒泡阶段 除非使用addEventListener 特别指定 否则执行的都是冒泡阶段</span><br><span class="line"></span><br><span class="line">addEventListener可以设置事件具体执行那个阶段的事件流</span><br><span class="line">元素.addEventListener(<span class="string">&quot;事件类型&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>);<span class="comment">//执行事件捕获阶段 和 确定目标阶段</span></span><br><span class="line">元素.addEventListener(<span class="string">&quot;事件类型&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">false</span>/不传(默认是<span class="literal">false</span>));<span class="comment">//执行确定目标阶段 和 事件冒泡阶段</span></span><br><span class="line">由于IE中的dom事件流 只有冒泡阶段 没有捕获阶段 因此 根本不需要设置</span><br><span class="line"></span><br><span class="line">有时事件冒泡 会给我们 带来一些不必要的麻烦，因此我们需要阻止冒泡</span><br><span class="line">阻止冒泡的方法</span><br><span class="line"><span class="number">1.</span>标准浏览器中 : 事件对象.stopPropagation();</span><br><span class="line"><span class="number">2.</span>IE浏览器中 : 事件对象.cancelBubble = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onclick  绑定的事件    解绑方式 : 元素.onclick = <span class="literal">null</span>;</span><br><span class="line">addEventListener  绑定的事件   解绑方式  : 元素.removeEventListener(<span class="string">&quot;要解绑的事件类型&quot;</span>,处理函数)</span><br><span class="line">attachEvent  绑定的事件   解绑方式 : 元素.detachEvent(<span class="string">&quot;要解绑的事件类型&quot;</span>,处理函数)</span><br></pre></td></tr></table></figure><h2 id="取消默认行为"><a href="#取消默认行为" class="headerlink" title="取消默认行为"></a>取消默认行为</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在js中 很多事件 都有自己的默认行为</span><br><span class="line">例如 点击事件 添加给a标签后  就会默认跳转页面   鼠标右击事件 会默认弹出菜单</span><br><span class="line">on方式 添加的事件  阻止默认行为的方法 : 元素.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">addEventListener方式 添加的事件  阻止默认行为的方法 : 事件对象.preventDefault()</span><br><span class="line">attachEvent方式 添加的时间  阻止默认行为的方法 : 事件对象.returnValue = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="其他类型的事件"><a href="#其他类型的事件" class="headerlink" title="其他类型的事件"></a>其他类型的事件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">之前 我们接触过 鼠标类型的事件</span><br><span class="line">键盘类事件</span><br><span class="line">onkeyup  : 键盘抬起事件  键盘弹起时触发该事件</span><br><span class="line">onkeydown  : 键盘按下事件  键盘按下时触发该事件</span><br><span class="line">注意：当我们一直按住键 不松手的时候  onkeydown 会一直触发  onkeyup只在松手的瞬间触发</span><br><span class="line"></span><br><span class="line">键盘类事件的事件对象</span><br><span class="line">事件重要属性 : <span class="number">1.</span>key : 按下的键 的 键值  可以很方便的 获取键值 但是 有兼容性问题</span><br><span class="line">              <span class="number">2.</span>keyCode : 按下的键 的 键盘码  就是每一个键值 对应的unicode编码 没有兼容性问题</span><br><span class="line">              我们可以通过键盘值 或 键盘码 来判断当前用户按下的是哪一个键  更推荐使用keyCode</span><br><span class="line">滚轮类事件</span><br><span class="line">谷歌和IE  onmousewheel   会在鼠标滚轮滚动的时候 触发该事件</span><br><span class="line">火狐      DOMMouseScroll 会在鼠标滚轮滚动时  触发该事件  只能使用addEventListener添加事件</span><br><span class="line"></span><br><span class="line">滚轮事件的兼容问题</span><br><span class="line">元素.onmousewheel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//在谷歌和IE中可用</span></span><br><span class="line"><span class="keyword">if</span>(元素.addEventListener!=<span class="literal">undefined</span>)&#123;</span><br><span class="line">   <span class="comment">//证明我们处于标准浏览器中</span></span><br><span class="line">   元素.addEventListener(<span class="string">&quot;DOMMouseScroll&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">IE执行结果为 只添加 onmousewheel 事件</span><br><span class="line">谷歌执行结果为 添加onmousewheel 和 DOMMouseScroll 两个事件</span><br><span class="line">火狐执行结果 和 谷歌一样</span><br><span class="line"></span><br><span class="line">通过 滚轮事件的 事件对象 获取滚轮的滚动方向</span><br><span class="line">在onmousewheel的事件对象中 有一个属性 wheelDelta  如果值为正 表示鼠标向上滚动  如果值为负 表示鼠标向下滚动</span><br><span class="line">在DOMMouseScroll的事件对象中 记录鼠标滚动方向的属性为 detail 如果值为正 表示鼠标向下滚动 如果值为负 表示鼠标向上滚动</span><br></pre></td></tr></table></figure><h2 id="事件代理（委托）"><a href="#事件代理（委托）" class="headerlink" title="事件代理（委托）"></a>事件代理（委托）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当我们要给子元素绑定事件的时候，我们可以使用事件代理的方式进行。 </span><br><span class="line">即 <span class="number">1.</span>将事件绑定给 所有子元素的父元素</span><br><span class="line">   <span class="number">2.</span>利用事件对象 的 target属性 来判断 当前实际触发事件的元素 是不是子元素</span><br><span class="line">   <span class="number">3.</span>如果是子元素 就执行事件处理函数 如果不是子元素 就不执行</span><br><span class="line">事件委托的效果 一般用于 要添加事件的子元素数量过多的时候（事件委托可以更节省性能） 或 后续要追加新的子元素 这两种情况</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM</title>
      <link href="2021/05/02/10-BOM/"/>
      <url>2021/05/02/10-BOM/</url>
      
        <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="DOM操作表单"><a href="#DOM操作表单" class="headerlink" title="DOM操作表单"></a>DOM操作表单</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>表单元素相关事件</span><br><span class="line">  form元素专属事件</span><br><span class="line">  <span class="number">1.</span>onsubmit : 表单提交事件  这一事件 会在 表单被提交的瞬间触发  </span><br><span class="line">    如果在 事件处理函数中 写入 <span class="keyword">return</span> <span class="literal">false</span>  即可阻止 表单提交</span><br><span class="line">  <span class="number">2.</span>onreset : 表单重置事件 这一事件 会在 表单被重置的瞬间触发</span><br><span class="line">    如果在 事件处理函数中 写入 <span class="keyword">return</span> <span class="literal">false</span>  即可阻止 表单重置</span><br><span class="line">  input元素专属事件</span><br><span class="line">  <span class="number">1.</span>onfocus : 聚焦事件 这一事件 会在input获取到焦点的时候 触发</span><br><span class="line">  <span class="number">2.</span>onblur :  离焦事件 这一事件 会在input失去焦点的时候 触发</span><br><span class="line"><span class="number">2.</span>表单元素相关方法</span><br><span class="line">  form专属方法</span><br><span class="line">  <span class="number">1.</span>submit : form.submit()  可以提交表单</span><br><span class="line">  <span class="number">2.</span>reset  : form.reset()  可以重置表单</span><br><span class="line">  input的专属方法</span><br><span class="line">  <span class="number">1.</span>focus : input.focus()  可以使input得到焦点</span><br><span class="line">  <span class="number">2.</span>blur : input.blur()  可以使input失去焦点</span><br><span class="line">  <span class="number">3.</span>select : input.select()  可以使input被选中</span><br><span class="line"><span class="number">3.</span>获取表单元素的 简便方法</span><br><span class="line">  form元素.表单Name名  即可得到form中的表单元素</span><br></pre></td></tr></table></figure><h2 id="BOM的初识"><a href="#BOM的初识" class="headerlink" title="BOM的初识"></a>BOM的初识</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>BOM : Browser <span class="built_in">Object</span> Model 浏览器对象模型</span><br><span class="line"><span class="number">2.</span>定义 : 是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。</span><br><span class="line">BOM 是操作浏览器的一个 对象结构  且  不受页面内容影响  熟练掌握</span><br><span class="line">BOM的组成 : BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201225112229629.png" alt="image-20201225112229629"></p><h2 id="BOM的重要对象"><a href="#BOM的重要对象" class="headerlink" title="BOM的重要对象"></a>BOM的重要对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">window</span>对象</span><br><span class="line">  <span class="number">1.</span>系统对话框</span><br><span class="line">    <span class="number">1.</span>alert(<span class="string">&quot;要提示的内容&quot;</span>)</span><br><span class="line">    <span class="number">2.</span><span class="built_in">console</span>.log(<span class="string">&quot;要在控制台打印的内容&quot;</span>)</span><br><span class="line">    <span class="number">3.</span>confirm(<span class="string">&quot;要弹窗输入的内容&quot;</span>)</span><br><span class="line">      作用 : 在浏览器窗口中 弹出一个询问对话框  有两个选项 确定 和 取消  用户可以进行选择 </span><br><span class="line">             如果选确定  返回值为<span class="literal">true</span>   如果选取消  返回值为<span class="literal">false</span></span><br><span class="line">    <span class="number">4.</span>prompt(<span class="string">&quot;要弹窗询问的信息&quot;</span>)</span><br><span class="line">      作用 : 在浏览器窗口中 弹出一个询问对话框  有一个输入框 和 两个选项(确定和取消)</span><br><span class="line">             如果用户选确定 返回值为 输入框的内容  如果用户选取消 返回值为 <span class="literal">null</span></span><br><span class="line">  <span class="number">2.</span><span class="built_in">window</span>对象的方法</span><br><span class="line">    <span class="number">1.</span>open : 打开新页面</span><br><span class="line">      用法 : <span class="built_in">window</span>.open(url地址,跳转方式,设置新窗口大小,是否替换上一条历史记录)</span><br><span class="line">  描述 : url地址 设置要跳转页面的地址  必传</span><br><span class="line">             跳转方式  _blank（新窗口打开） / _self (当前窗口跳转)  默认 _blank</span><br><span class="line">  设置新窗口大小 : 在新窗口打开的情况下 才可以设置新窗口大小   默认 不设置</span><br><span class="line">             是否替换上一条历史记录 : 是一个布尔值  如果为<span class="literal">true</span> 表示新页面替换上一条历史记录 如果<span class="literal">false</span> 就不替换   默认 不替换</span><br><span class="line">    <span class="number">2.</span>close : 关闭页面</span><br><span class="line">      用法 : <span class="built_in">window</span>.close();</span><br><span class="line">      作用 : 关闭当前窗口</span><br><span class="line">    <span class="number">3.</span>总结 : <span class="number">1.</span>上述两个方法 都是<span class="built_in">window</span>对象的方法  因此可以省略<span class="built_in">window</span>  open()  close()</span><br><span class="line">    <span class="number">2.</span>如果写作 行内引入的 js代码  则 <span class="built_in">window</span>不能省略</span><br><span class="line">               因为 内部引入的js代码 写在script标签中  具备全局作用域  可以直接使用<span class="built_in">window</span>的属性   和方法。  但行内引入 则是将js代码 写入html标签中  没有全局作用域  因此<span class="built_in">window</span>对象   不能省略</span><br><span class="line">               </span><br><span class="line"> <span class="number">2.</span>location : 本地</span><br><span class="line">   <span class="number">1.</span>location对象的方法</span><br><span class="line">     <span class="number">1.</span>location.reload()   作用 : 刷新页面</span><br><span class="line">     <span class="number">2.</span>location = url地址   作用 : 跳转页面</span><br><span class="line">   <span class="number">2.</span>location对象的属性</span><br><span class="line">    <span class="number">1.</span>hash : location.hash  表示获取地址栏中的锚链接值</span><br><span class="line">     <span class="number">2.</span>host : location.host  表示获取地址中的服务器名称和端口号(如果有的话)  必须在服务器环境中 打开代码，才能获取到结果  否则 只能得到空串</span><br><span class="line">     <span class="number">3.</span>hostname : location.hostname  表示获取地址中的服务器名称</span><br><span class="line">     <span class="number">4.</span>href : location.href  url地址（地址栏中的全部内容）</span><br><span class="line">     <span class="number">5.</span>pathname : location.pathname   url地址中的路径</span><br><span class="line">     <span class="number">6.</span>port : location.port  端口号</span><br><span class="line">     <span class="number">7.</span>protocol : location.protocol  获取地址中的协议部分</span><br><span class="line">     <span class="number">8.</span>search : location.search  获取地址中 的 提交数据部分</span><br><span class="line">     </span><br><span class="line">     https:<span class="comment">//   www.baidu.com/   :80</span></span><br><span class="line">      协议      服务器名称        端口号</span><br><span class="line">      常见协议： http  https ftp file（本地打开）</span><br><span class="line"> <span class="number">3.</span>history </span><br><span class="line">   <span class="number">1.</span>back :  </span><br><span class="line"> 用法 : history.back();</span><br><span class="line"> 作用 : 返回 历史记录中 上一条 记录的地址  和 浏览器的后退按钮效果一样</span><br><span class="line">   <span class="number">2.</span>forward : </span><br><span class="line"> 用法 : history.forward();</span><br><span class="line"> 作用 : 前进到 历史记录中的 下一条 记录的地址   和 浏览器的前进按钮效果一样</span><br><span class="line">   <span class="number">3.</span>go : </span><br><span class="line"> 用法 : history.go(n)</span><br><span class="line"> 作用 : n是一个非<span class="number">0</span>数字  如果n&gt;<span class="number">0</span>表示 要前进n步  n&lt;<span class="number">0</span> 表示 要后退n步</span><br><span class="line"> <span class="number">4.</span>navigator</span><br><span class="line">   主要作用 : 用来记录一些浏览器相关的 信息</span><br><span class="line">   cookie</span><br><span class="line">   用户代理 navigator.userAgent</span><br></pre></td></tr></table></figure><h2 id="BOM操作元素位置和大小"><a href="#BOM操作元素位置和大小" class="headerlink" title="BOM操作元素位置和大小"></a>BOM操作元素位置和大小</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">client系列</span><br><span class="line"><span class="number">1.</span>元素.clientWidth/clientHeight    </span><br><span class="line">  作用 : 可以获取 元素 的 可视宽高（自身宽高+padding）</span><br><span class="line"><span class="number">2.</span>元素.clientLeft/clientTop    了解</span><br><span class="line">  作用 : 可以获取 元素的 左边框  和  上边框 宽度</span><br><span class="line">    <span class="number">3.</span>总结 : client系列的所有方法 都是只读的  只能获取 不能设置</span><br><span class="line">offset系列</span><br><span class="line"><span class="number">1.</span>元素.offsetWidth/offsetHeight    </span><br><span class="line">  作用 : 可以获取 元素 的 占位宽高（自身宽高+padding+border）</span><br><span class="line"><span class="number">2.</span>元素.offsetLeft/offsetTop    熟练掌握</span><br><span class="line">  作用 : 可以获取 元素到 带定位父元素的左侧和顶部的距离  如果没有带定位父元素 就相对于body计算</span><br><span class="line">    <span class="number">3.</span>总结 : offest系列 也是只读的 只能获取 不能设置</span><br><span class="line">scroll系列</span><br><span class="line"><span class="number">1.</span>元素.scrollWidth/scrollHeight</span><br><span class="line">  作用 : 可以获取 元素 实际内容的宽高  只读 只能获取 不能设置</span><br><span class="line"><span class="number">2.</span>元素.scrollLeft / scrollTop</span><br><span class="line">  作用 : 可以获取 元素内容 被卷去的宽高  可读写  既可获取  也可设置</span><br><span class="line">页面被卷去的高度  就是  html标签内容 被卷去的高度  </span><br><span class="line">我们在js中使用  <span class="built_in">document</span>.documentElement 表示 html标签</span><br><span class="line">由于 老版本火狐浏览器 不支持这种表示方式 因此可以做如下兼容</span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop：获取页面被卷去的高</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">懒加载：是一种 页面性能优化 的处理方式</span><br><span class="line">BOM的事件</span><br><span class="line"> onscroll：滚动条滚动时触发</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM</title>
      <link href="2021/05/02/9-DOM/"/>
      <url>2021/05/02/9-DOM/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="昨日回顾"><a href="#昨日回顾" class="headerlink" title="昨日回顾"></a>昨日回顾</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">every: 数组.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> 条件 &#125;)</span><br><span class="line">       作用 : 自动循环数组中的所有数组项 判断每个数组项 是否都满足条件  如果都满足 返回<span class="literal">true</span> 有一个               不满足  返回<span class="literal">false</span></span><br><span class="line">some : 数组.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> 条件 &#125;)</span><br><span class="line">       作用 : 自动循环数组中的所有数组项 判断每个数组项 是否都满足条件  只要有一个满足 就返回<span class="literal">true</span>               都不满足  返回<span class="literal">false</span></span><br><span class="line">filter : 数组.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> 条件 &#125;)</span><br><span class="line">        作用 : 自动循环数组中的所有数组项 判断每个数组项 是否满足条件  如果满足 就留下这个数组项 如果不满足  就舍弃掉这个数组项 最后 将留下的数组项 存入一个新数组中 并返回新数组</span><br><span class="line">map : 数组.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> 操作 &#125;)</span><br><span class="line">      作用 : 自动循环数组中的所有数组项 给每个数组项 都执行指定的操作 后将执行完操作的数组项 存入一    个新数组中 并返回新数组</span><br><span class="line">forEach : 数组.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; 任意要循环执行的代码 &#125;)</span><br><span class="line"> 作用 : 自动循环数组所有数组项，每循环一次 执行一次要循环执行的代码</span><br></pre></td></tr></table></figure><h2 id="DOM的定义"><a href="#DOM的定义" class="headerlink" title="DOM的定义"></a>DOM的定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js的组成成分：ECMAScript + DOM + BOM</span><br><span class="line">DOM : Document <span class="built_in">Object</span> Model 文档对象模型  主要用来帮助开发者 操作 html文档</span><br><span class="line">定义 : DOM是针对 HTML 和 XML 的一个 API集合，即开发者可以通过 DOM 来操作 HTML文档 或者 XML文档。</span><br><span class="line">      API : application program interface --&gt; 应用程序接口 --&gt; 方法函数 </span><br><span class="line">      XML : 可拓展标记语言  很像html 但 xml和html唯一的区别是 xml中没有预制的标签 所有的标签都是             用户自定义的。 xml中不存在单标签   了解</span><br><span class="line">DOM操作HTML 和 XML文档的方式 是 将html/xml文档 先抽象化为 一个树状结构(DOM树) 每一个html中的标签都是树状结构中的一个节点  DOM 是通过 节点 来操作html/xml文档的</span><br><span class="line">每个HTML文档有且仅有一个根节点，称之为 文档节点，即html  html在这里表示整个html文档  而非html标签</span><br><span class="line">根节点(文档节点) 写作 <span class="built_in">document</span></span><br><span class="line">html标签节点 : <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;html&quot;</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201224101838732.png" alt="image-20201224101838732"></p><h3 id="DOM的节点"><a href="#DOM的节点" class="headerlink" title="DOM的节点"></a>DOM的节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">节点的分类</span><br><span class="line"><span class="number">1.</span>标签节点</span><br><span class="line"><span class="number">2.</span>文本节点</span><br><span class="line"><span class="number">3.</span>属性节点</span><br><span class="line"><span class="number">4.</span>注释节点</span><br><span class="line">节点的方法</span><br><span class="line"><span class="number">1.</span>获取节点类型的方法：nodeType   节点.nodeType  文本节点:<span class="number">3</span>  标签节点:<span class="number">1</span>  注释节点:<span class="number">8</span>  属性节点:<span class="number">2</span>     这个方法 主要用于判断 节点的类型</span><br><span class="line"><span class="number">2.</span>获取节点名称的方法:nodeName  节点.nodeName  文本节点:#text 标签节点:大写的标签名 注释节点:#comment  </span><br><span class="line"><span class="number">3.</span>操作节点内容的方法:nodeValue </span><br><span class="line">  获取：节点.nodeValue 标签节点：<span class="literal">null</span>  注释节点：注释的内容  文本节点：文本内容</span><br><span class="line">  设置：节点.nodeValue = <span class="string">&quot;xxx&quot;</span> 只针对文本节点</span><br></pre></td></tr></table></figure><h2 id="DOM获取节点"><a href="#DOM获取节点" class="headerlink" title="DOM获取节点"></a>DOM获取节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>获取子节点</span><br><span class="line">  childNodes : 元素节点.childNodes  得到元素的所有子节点</span><br><span class="line">  children : 元素节点.children  得到元素的所有子元素节点</span><br><span class="line"><span class="number">2.</span>获取父节点</span><br><span class="line">  parentNode : 节点.parentNode  得到节点的父节点</span><br><span class="line">  offsetParent : 节点.offsetParent  得到节点的带定位父节点</span><br><span class="line">      作用: 获取带定位的父节点 如果直接父节点不带定位 就获取上一级带定位的父节点，一直                        找到body，如果有父节点带定位 就获取 如果没有 就获取body</span><br><span class="line"><span class="number">3.</span>获取兄弟节点</span><br><span class="line">  firstChild/lastChild : 在标准浏览器中 获取元素的 第一个/最后一个 子节点  在ie8及以下浏览器中 获取的是元素的 第一个/最后一个 子元素</span><br><span class="line">  first/lastElementChild : 获取元素的 第一个/最后一个 子元素  这个方法在ie8及以下浏览器中 不支    持，只能获取到<span class="literal">undefined</span></span><br><span class="line">  获取第一个/最后一个子元素 的 兼容写法</span><br><span class="line">  <span class="keyword">if</span>(元素.first/lastElementChild==<span class="literal">undefined</span>)&#123;</span><br><span class="line">     元素.firstChild/lastChild;<span class="comment">//在ie中</span></span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     元素.first/lastElementChild;<span class="comment">//在标准浏览器中</span></span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line"> 元素.firstElementChild || 元素.firstChild  短路运算</span><br><span class="line"> <span class="comment">//逻辑运算 如果 操作数是布尔值 就执行逻辑运算  如果操作数不是布尔值 就执行 短路运算</span></span><br><span class="line"> </span><br><span class="line"> 短路运算的运算规则 : 算式的值 就是 算式中 起决定性作用的 操作数的值</span><br><span class="line"> <span class="string">&quot;&quot;</span> &amp;&amp; <span class="number">0</span>; </span><br><span class="line"> <span class="number">1.</span>先将两个操作数 都 转换为布尔值 <span class="literal">false</span> &amp;&amp; <span class="literal">false</span> === <span class="literal">false</span></span><br><span class="line"> <span class="number">2.</span>判断 哪一个值 起了决定性作用  短路运算算式的值 就是起决定性作用的操作数</span><br><span class="line"></span><br><span class="line"> &#123;&#125; &amp;&amp; <span class="number">0</span>;  <span class="number">0</span>  任何复杂类型数据 转换为 布尔值 结果都是 <span class="literal">true</span></span><br><span class="line"> <span class="number">1.</span><span class="literal">true</span> &amp;&amp; <span class="literal">false</span> === <span class="literal">false</span></span><br><span class="line"> <span class="number">2.</span>由于第二个操作数决定了算式的值  因此 短路运算的值 为第二个操作数</span><br><span class="line"> </span><br><span class="line"> <span class="number">0</span> || <span class="literal">NaN</span>; <span class="literal">NaN</span> </span><br><span class="line"> <span class="number">1.</span> <span class="literal">false</span> || <span class="literal">false</span> === <span class="literal">false</span></span><br><span class="line"> <span class="number">2.</span> <span class="literal">NaN</span>决定了算式的值</span><br><span class="line"> </span><br><span class="line"> nextsibling : 获取下一个兄弟节点（标准浏览器中）/ 获取下一个兄弟元素(IE浏览器中)</span><br><span class="line"> previousSibling : 获取上一个兄弟节点(标准浏览器)/获取上一个兄弟元素(IE浏览器)  </span><br><span class="line"></span><br><span class="line">nextElementSibling : 获取下一个兄弟元素(标准浏览器中 在ie中值为<span class="literal">undefined</span>) </span><br><span class="line">previousElementSibling : 获取上一个兄弟元素(标准浏览器中 在ie中值为<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><h2 id="DOM操作节点"><a href="#DOM操作节点" class="headerlink" title="DOM操作节点"></a>DOM操作节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建节点</span><br><span class="line">  createElement : 创建元素节点  常用</span><br><span class="line">  用法 : <span class="built_in">document</span>.createElement(<span class="string">&quot;要创建的标签名&quot;</span>);</span><br><span class="line">  createTextNode : 创建文本节点</span><br><span class="line">  用法 : <span class="built_in">document</span>.createTextNode(<span class="string">&quot;文本内容&quot;</span>)   不常用</span><br><span class="line">  注意 : 创建节点之后 页面上并不会显示  需要 追加节点 才能在页面上显示</span><br><span class="line"><span class="number">2.</span>追加节点</span><br><span class="line">  appendChild</span><br><span class="line">  用法 : 父元素.appendChild(要追加的子节点)</span><br><span class="line">  作用 : 将子节点 追加到 父元素的 末尾</span><br><span class="line">  注意 : 当追加的节点 是 页面上已经存在的节点 时  就会产生 位置的移动</span><br><span class="line">  </span><br><span class="line">  insertBefore</span><br><span class="line">  用法 : 父元素.insertBefore(新子节点,旧子节点);</span><br><span class="line">  作用 : 将 新子节点  追加到 父元素中 已经存在  旧子节点的 前面</span><br><span class="line">  注意 : 当 插入的子节点 是 页面上 已经存在的节点  就会产生 位置的移动</span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>删除节点</span><br><span class="line">  removeChild</span><br><span class="line">  用法 : 父元素.removeChild(要移除的子节点);</span><br><span class="line">  作用 : 移除父元素中的 指定子节点</span><br><span class="line">  remove</span><br><span class="line">  用法 : 节点.remove()</span><br><span class="line">  作用 : 移除 调用remove方法 的 节点</span><br><span class="line">  </span><br><span class="line"><span class="number">4.</span>替换节点 </span><br><span class="line">  replaceChild</span><br><span class="line">  用法 : 父元素..replaceChild(新子节点,旧子节点);</span><br><span class="line">  作用 : 使用新子节点 替换掉 父元素中 原本存在的 旧子节点</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>克隆节点</span><br><span class="line">  cloneNode</span><br><span class="line">  用法 : 节点.cloneNode();  浅层克隆</span><br><span class="line">  注意 : 如果直接调用 cloneNode方法 会将指定节点克隆下来  但是 节点内容 克隆不到  如果想拿到内容，  需要进行深层克隆</span><br><span class="line">  用法 : 节点.cloneNode(<span class="literal">true</span>);  深层克隆</span><br><span class="line"><span class="number">6.</span>获取元素的新方法</span><br><span class="line">  querySelector</span><br><span class="line">  用法 : 范围.querySelector(<span class="string">&quot;css3选择器&quot;</span>);</span><br><span class="line">  作用 : 通过css3选择器 来 获取单个元素 如果有多个元素都满足选择器条件 就获取 第<span class="number">0</span>个 </span><br><span class="line">  querySelectorAll</span><br><span class="line">  用法 : 范围.querySelectorAll(<span class="string">&quot;css3选择器&quot;</span>);</span><br><span class="line">  作用 : 通过css3选择器 来 批量获取元素  得到的是一个包含所有满足选择器条件的元素的 伪数组</span><br><span class="line">  注意 : 这两个方法 在IE8 及以下浏览器中 不能使用</span><br><span class="line"><span class="number">7.</span>操作元素属性的新方法</span><br><span class="line">  元素.属性名</span><br><span class="line">  元素.属性名 = 属性值</span><br><span class="line">  获取属性</span><br><span class="line">  getAttribute</span><br><span class="line">  用法: 元素.getAttribute(<span class="string">&quot;属性名&quot;</span>);</span><br><span class="line">  作用: 获取元素的 指定属性值</span><br><span class="line">  设置属性</span><br><span class="line">  setAttribute</span><br><span class="line">  用法: 元素.setAttribute(<span class="string">&quot;属性名&quot;</span>,<span class="string">&quot;要设置的值&quot;</span>);</span><br><span class="line">  作用: 设置元素的 指定属性值 为 指定值</span><br><span class="line">  getAttribute和setAttribute 既可以 操作元素的自带属性 也可以操作元素的非自带属性和自定义属性</span><br></pre></td></tr></table></figure><h2 id="DOM操作表格"><a href="#DOM操作表格" class="headerlink" title="DOM操作表格"></a>DOM操作表格</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DOM具备一些专门用来操作 表格标签 table 的方法</span><br><span class="line">tHead : table.tHead  可以获取到表格的头部</span><br><span class="line">tBodies : table.tBodies 可以获取到 所有表格主体的集合 是一个伪数组  如果想获取到 某一个tbody 需  要加下标</span><br><span class="line">tFoot : table.tFoot  可以获取到 表格底部</span><br><span class="line">rows : table.rows 获取table中的所有行组成的伪数组  thead/tbody/tfoot.rows 获取表头/表格主体/表  格底部的所有行</span><br><span class="line">cells : rows[n].cells  获取指定行中所有列组成的伪数组   注意 : 范围只能是指定的某一行  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组对象</title>
      <link href="2021/05/02/8-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/05/02/8-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h1><h2 id="创建数组-熟悉"><a href="#创建数组-熟悉" class="headerlink" title="创建数组   熟悉"></a>创建数组   熟悉</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] length <span class="number">5</span>  字面量创建</span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,,<span class="number">4</span>,<span class="number">5</span>]  length <span class="number">6</span>  这里多了一个逗号 两个逗号中默认存在一个  空数组项</span><br><span class="line">  这样写 空数组项值为<span class="literal">undefined</span>  只能撑开数组的长度  直接打印数组 看不到空数组项</span><br><span class="line"><span class="number">2.</span><span class="keyword">var</span> arr = <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="number">3.</span><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);  实例化创建</span><br><span class="line"></span><br><span class="line">在js中 所有 数组和对象的数据类型 都是 object </span><br><span class="line">如果想区分一个数据是数组还是对象 可以 使用 <span class="keyword">instanceof</span>  熟练运用</span><br><span class="line">用法 : 数组/对象  <span class="keyword">instanceof</span>  <span class="built_in">Array</span>    </span><br><span class="line">作用 : 如果是数组 返回值 为 <span class="literal">true</span>   如果是对象  返回值 为 <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>增添和删除数组项的方法</span><br><span class="line">  push和pop    操作数组末尾</span><br><span class="line">  push : 数组.push(要添加的数组项<span class="number">1</span>,数组项<span class="number">2</span>,....)</span><br><span class="line">  作用 : 将所有要添加的数组项 全部 按顺序 追加到 数组的末尾</span><br><span class="line">  返回值 : 追加之后 数组的长度</span><br><span class="line">  pop : 数组.pop()</span><br><span class="line">  作用 : 删除数组的最后一项</span><br><span class="line">  返回值 : 被删除的数组项</span><br><span class="line">  </span><br><span class="line">  unshift和shift   操作数组开头</span><br><span class="line">  unshift : 数组.unshift(要添加的数组项<span class="number">1</span>,数组项<span class="number">2</span>,....)</span><br><span class="line">  作用 : 将所有要添加的数组项 全部 按顺序 追加到 数组的开头</span><br><span class="line">  返回值 : 追加之后 数组的长度</span><br><span class="line">  shift : 数组.shift()</span><br><span class="line">  作用 : 删除数组的第一项</span><br><span class="line">  返回值 : 被删除的数组项 </span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span>灵活操作数组的方法 splice</span><br><span class="line">  <span class="number">1.</span>删除数组项</span><br><span class="line">  用法 : 数组.splice(起始下标,要删除的项数);</span><br><span class="line">  作用 : 从起始下标开始 删除指定的项数的数组项</span><br><span class="line">  <span class="number">2.</span>替换数组项</span><br><span class="line">  用法 : 数组.splice(起始下标,要删除的项数,用来替换的数组项<span class="number">1</span>,数组项<span class="number">2</span>,...)</span><br><span class="line">  作用 : 先将要删除的数组项 删掉  腾出空间  之后 将后续替换的数组项 插入之前的空间中</span><br><span class="line">  注意 : 删除的项数 和 替换的项数 不用相同</span><br><span class="line">  <span class="number">3.</span>插入数组项</span><br><span class="line">  用法 : 数组.splice(起始下标,要删除的项数(<span class="number">0</span>),用来替换的数组项<span class="number">1</span>,数组项<span class="number">2</span>,...)</span><br><span class="line">  作用 : 先删除，但由于删除的项数为<span class="number">0</span> 因此实际并未删除任何数组项 之后 将用来替换的数组项 插入起始下      标位置</span><br><span class="line">  注意 : 插入的位置 在 起始下标 前面</span><br><span class="line"><span class="number">3.</span>将数组拼成字符串的方法 join</span><br><span class="line">  用法<span class="number">1</span> : 数组.join(<span class="string">&quot;拼接标识&quot;</span>);</span><br><span class="line">  作用 : 使用指定的拼接标识 将 数组项 全部拼成一个 字符串</span><br><span class="line">  </span><br><span class="line">  用法<span class="number">2</span> : 数组.join();</span><br><span class="line">  作用 :使用默认的拼接标识 进行拼接  默认的拼接标识为 逗号</span><br><span class="line">  </span><br><span class="line">  字符串 的 split  是将 字符串按照切割标识 切割成数组  而 数组的join方法 则是将数组项 按照拼接标识   拼接成字符串   因此我们说 split 和 join  是一对逆运算</span><br><span class="line"><span class="number">4.</span> 数组的翻转方法 reverse</span><br><span class="line">   用法 : 数组.reverse();</span><br><span class="line">   作用 : 将数组所有数组项的位置 进行翻转 后面变前面 前面变后面</span><br><span class="line">   </span><br><span class="line"><span class="number">5.</span> 数组的拼接 concat</span><br><span class="line">   用法 : 数组.concat(其他数组/数组项);</span><br><span class="line">   作用 : 将其他数组 或 数组项 拼接到 原数组的末尾</span><br><span class="line">   注意 : concat方法 不会改变原数组  而是将 拼接好的结果生成为新数组 返回出来</span><br><span class="line"><span class="number">6.</span>获取指定数组项下标的方法 indexOf</span><br><span class="line">  用法 : 数组.indexOf(指定的数组项)</span><br><span class="line">  作用 : 获取指定数组项 在 数组中 第一次出现的下标  如果有 或获取下标  如果没有 就得到-<span class="number">1</span></span><br><span class="line">  用法<span class="number">2</span> : 数组.indexOf(指定数组项,起始下标)</span><br><span class="line">  作用 : 从起始下标开始 先后查找 获取指定数组项第一次出现的下标 。。。。。。</span><br><span class="line">  数组也有 lastIndexOf 和 字符串的 lastIndexOf 完全一样</span><br><span class="line"><span class="number">7.</span>截取数组的方法 slice</span><br><span class="line">  用法 : 数组.slice(起始下标，结束下标)</span><br><span class="line">  作用 : 从起始下标开始 一直截取到 结束下标 将其中的数组项截取出来  生成一个新数组</span><br><span class="line">  注意 : 能取到开头 取不到结尾 且 本方法 不改变 原数组。</span><br><span class="line"><span class="number">8.</span>判断数据是不是数组的方法  isArray</span><br><span class="line">  用法 : <span class="built_in">Array</span>.isArray(数据)</span><br><span class="line">  作用 : 如果数据是数组 返回<span class="literal">true</span>  否则 返回<span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="数组排序算法和排序实例"><a href="#数组排序算法和排序实例" class="headerlink" title="数组排序算法和排序实例"></a>数组排序算法和排序实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>数组的排序算法</span><br><span class="line">数组去重算法</span><br><span class="line">  思路： <span class="number">1.</span>循环所有数组项</span><br><span class="line">      <span class="number">2.</span>拿第<span class="number">0</span>项 和后面所有项进行比较  如果有重复的  就删除掉后面的重复项</span><br><span class="line">        <span class="number">3.</span>顺次向后 取第一项 第二项...  和后面的数组项进行比较</span><br><span class="line">选择排序法 (假设为 从小到大)</span><br><span class="line">   思路: <span class="number">1.</span>循环所有数组项</span><br><span class="line">        <span class="number">2.</span>使用当前项 和 后面所有数组项进行比较 如果后面有比当前项还小的数组项 就赋值给当前数组项</span><br><span class="line">冒泡排序法  (假设为 从小到大)</span><br><span class="line">   思路: <span class="number">1.</span>冒泡排序就是 相邻数组项 两两比较  如果后面比前面小 就交换二者位置</span><br><span class="line">   <span class="number">2.</span>冒泡排序 最多排  数组.length-<span class="number">1</span>轮  每一轮 最多排 数组.length-<span class="number">1</span>次</span><br><span class="line">        </span><br><span class="line"><span class="number">2.</span>数组的排序方法 sort</span><br><span class="line">  <span class="number">1.</span>用法<span class="number">1</span> : 数组.sort();  作用 : 按照默认的排序规则 给数组排序</span><br><span class="line">  注意 : 默认的排序规则 是 按照数组项的 unicode编码 进行排序  比较也是按位进行的</span><br><span class="line">  <span class="number">2.</span>用法<span class="number">2</span> : 数组.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> a-b/b-a; &#125;)</span><br><span class="line">    作用 : 如果函数中 返回 a-b 从小到大排  如果返回 b-a 从大到小排</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>排序实例</span><br></pre></td></tr></table></figure><h2 id="数组的迭代-循环-方法"><a href="#数组的迭代-循环-方法" class="headerlink" title="数组的迭代(循环)方法"></a>数组的迭代(循环)方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">every  了解</span><br><span class="line">用法 : 数组.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> item&gt;<span class="number">10</span> &#125;);</span><br><span class="line">作用 : 循环整个数组中的所有数组项 idx表示数组下标 item表示数组项  判断 数组中所有数组项是否满足 函   数中的条件  如果都满足 返回<span class="literal">true</span>   如果有一个不满足 返回<span class="literal">false</span>    不常用</span><br><span class="line">some : 数组.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> item&gt;<span class="number">10</span> &#125;);   了解</span><br><span class="line">作用 : item表示数组项 idx表示下标 some会自动循环数组中所有数组项  如果有一个数组项满足返回的条件          some就返回<span class="literal">true</span>， 如果都不满足条件 some就返回<span class="literal">false</span>   不常用</span><br><span class="line">filter : 数组.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> item&gt;<span class="number">10</span> &#125;)</span><br><span class="line">作用 : filter会自动循环数组中所有数组项，和指定的条件 做比较  满足条件的数组项 会被留下来， 不满足        的直接舍弃。 最后 将满足条件的数组项 组成一个新数组 返回出来</span><br><span class="line">map : 数组.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; <span class="keyword">return</span> item+<span class="number">10</span> &#125;);</span><br><span class="line">作用 : map会自动循环数组项 给每一个数组项 执行指定的操作  最后将操作完的数组项 拼成一个新数组 返回  出来</span><br><span class="line">forEach : 数组.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123; 写入自定义的代码即可 &#125;)</span><br><span class="line">作用 : forEach会自动循环所有数组项 item表示数组项 idx表示下标 直接执行用户在函数中写入的代码</span><br></pre></td></tr></table></figure><h2 id="数组的快速排序法"><a href="#数组的快速排序法" class="headerlink" title="数组的快速排序法"></a>数组的快速排序法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二杈排序法</span><br><span class="line"><span class="number">1.</span>递归函数</span><br><span class="line">定义 : 递归函数 就是 函数体内部 调用自身 的函数</span><br><span class="line">示例 : <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123; a() &#125;;</span><br><span class="line">实际上 递归函数 就是 使用函数 实现循环 因此 一定要注意 设置好循环结束条件</span><br><span class="line"><span class="number">2.</span>二杈排序法</span><br><span class="line">思路: 假设从小到大排</span><br><span class="line"><span class="number">1.</span>在数组中 随便取一个 数组项(一般取中间项);</span><br><span class="line"><span class="number">2.</span>将中间项 从数组中 截取出来(数组中就没有中间项了)</span><br><span class="line"><span class="number">3.</span>循环剩余的所有数组项，和中间项比大小</span><br><span class="line">    <span class="number">4.</span>声明两个空数组 left right  将比中间项小的数组项 追加进 left  比中间项大的数组项 追加进 right</span><br><span class="line">    <span class="number">5.</span>将left+中间项+right</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Date对象 和 字符串对象</title>
      <link href="2021/05/02/7-Date%E5%AF%B9%E8%B1%A1%20%E5%92%8C%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/05/02/7-Date%E5%AF%B9%E8%B1%A1%20%E5%92%8C%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Date对象-和-字符串对象"><a href="#Date对象-和-字符串对象" class="headerlink" title="Date对象 和 字符串对象"></a>Date对象 和 字符串对象</h1><h2 id="Date对象-熟练掌握"><a href="#Date对象-熟练掌握" class="headerlink" title="Date对象  熟练掌握"></a>Date对象  熟练掌握</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>对象是专门用来操作 日期 和 时间 的 对象</span><br><span class="line"><span class="comment">//创建 Date对象</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">Tue Dec <span class="number">22</span> <span class="number">2020</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">45</span> GMT+<span class="number">0800</span> (中国标准时间)  date对象</span><br><span class="line">我们直接 <span class="keyword">new</span> <span class="built_in">Date</span>  得到的就是当前时间的时间对象</span><br><span class="line"></span><br><span class="line">操作date对象的方法</span><br><span class="line"><span class="number">1.</span>操作年份 : get/setFullYear  </span><br><span class="line">用法 : date对象.getFullYear() 获取年份</span><br><span class="line">  date对象.setFullYear(年份) 设置年份</span><br><span class="line"><span class="number">2.</span>操作月份 : get/setMonth</span><br><span class="line">  用法 : date对象.getMonth() 获取月份 js中月份是按照 <span class="number">0</span>-<span class="number">11</span> 进行计算的</span><br><span class="line">    date对象.setMonth(月份) 设置月份 js中设置月份 也应该设置为 <span class="number">0</span>-<span class="number">11</span></span><br><span class="line"><span class="number">3.</span>操作日期 : get/setDate  </span><br><span class="line">  用法 : date对象.getDate()获取日期</span><br><span class="line">    date对象.setDate(日期) 设置日期</span><br><span class="line"><span class="number">4.</span>操作周几 : getDay</span><br><span class="line">  用法 : date对象.getDay()获取周几</span><br><span class="line"><span class="number">5.</span>操作小时 : get/setHours</span><br><span class="line">  用法 : date对象.getHous()获取小时</span><br><span class="line">    date对象.setHours(小时) 设置小时 如果超过了 当天的时间  就顺次往后推一天</span><br><span class="line"><span class="number">6.</span>操作分钟 : get/setMinutes</span><br><span class="line">  用法 : date对象.getMinutes()获取分钟</span><br><span class="line">    date对象.setMinutes(分钟) 设置分钟 如果超过了 本小时的时间  就顺次往后推一小时</span><br><span class="line"><span class="number">7.</span>操作秒 : get/setSeconds</span><br><span class="line">  用法 : date对象.getSeconds()获取秒</span><br><span class="line">    date对象.setSeconds(秒) 设置秒 如果超过了 本分钟的时间  就顺次往后推一分钟</span><br><span class="line"><span class="number">8.</span>操作时间戳 : get/setTime</span><br><span class="line">  用法 : date对象.getTime()  获取时间戳  </span><br><span class="line">      date对象.setTime(n)  设置时间戳</span><br><span class="line">        时间戳 就是 当前时间 到 <span class="number">1970</span> 年 <span class="number">1</span>月 <span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> 的时间差  单位为ms</span><br><span class="line"></span><br><span class="line">创建时间的方法</span><br><span class="line"><span class="number">1.</span><span class="keyword">new</span> <span class="built_in">Date</span>()  创建当前时间的 时间对象</span><br><span class="line"><span class="number">2.</span><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2021</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);  创建 指定时间的 时间对象 月份为 <span class="number">0</span>-<span class="number">11</span></span><br><span class="line"><span class="number">3.</span><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2018,12,12,00:00:00&quot;</span>) 创建 指定时间的 时间对象 月份 <span class="number">1</span>-<span class="number">12</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">new</span> <span class="built_in">Date</span>(时间戳)  创建 指定时间的 时间对象</span><br><span class="line"></span><br><span class="line">特定格式的时间</span><br><span class="line"><span class="built_in">Date</span>对象.toString();<span class="comment">//将date对象转换为字符串</span></span><br><span class="line"><span class="built_in">Date</span>对象.toDateString();<span class="comment">//将date对象转换为日期字符串</span></span><br><span class="line"><span class="built_in">Date</span>对象.toTimeString();<span class="comment">//将date对象转换为时间字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>对象.toLocaleString();<span class="comment">//将date对象 转换为本地字符串</span></span><br><span class="line"><span class="built_in">Date</span>对象.toLocaleDateString();<span class="comment">//将date对象 转换为本地日期字符串</span></span><br><span class="line"><span class="built_in">Date</span>对象.toLocaleTimeString();<span class="comment">//将date对象 转换为本地时间字符串</span></span><br></pre></td></tr></table></figure><h2 id="Moment-js-了解"><a href="#Moment-js-了解" class="headerlink" title="Moment.js    了解"></a>Moment.js    了解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Moment.js是一个用来操作时间对象的插件</span><br><span class="line"><span class="number">0.</span>引入moment.js文件  &lt;script src=<span class="string">&quot;moment.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="number">1.</span>创建moment时间对象</span><br><span class="line">  moment()  可以得到当前时间的 时间对象</span><br><span class="line">  moment(<span class="string">&quot;2021-01-02&quot;</span>) 可以创建指定时间对象 需要符合时间格式</span><br><span class="line">  moment(时间戳)  可以根据时间戳创建指定时间的对象</span><br><span class="line">  moment(date对象) 可以根据原生date对象创建指定时间的moment对象</span><br><span class="line"><span class="number">2.</span>格式化moment时间对象</span><br><span class="line">  moment().format()  使用默认格式 格式化时间对象</span><br><span class="line">  moment().format(<span class="string">&quot;自定义格式&quot;</span>) </span><br><span class="line">  moment().toDate() 将moment时间对象 转换为 原生时间对象</span><br><span class="line">  moment().valueOf()  将moment时间对象 转换为 时间戳</span><br><span class="line"><span class="number">3.</span>获取和设置时间</span><br><span class="line">  获取</span><br><span class="line">  moment对象.month() <span class="number">0</span>-<span class="number">11</span></span><br><span class="line">  moment对象.get(<span class="string">&quot;year/month/date/hour/minute/second&quot;</span>)</span><br><span class="line">  设置</span><br><span class="line">  moment对象.month(月份) <span class="number">0</span>-<span class="number">11</span></span><br><span class="line">  moment对象.set(<span class="string">&quot;year&quot;</span>,<span class="number">2021</span>);</span><br><span class="line">  moment对象.dayOfYear() 获取或设置 当前日期是 今年的 第几天</span><br><span class="line">  moment对象.quarter()  获取当前季度</span><br><span class="line">  moment对象.daysInMonth()  获取当前月份的天数</span><br><span class="line"><span class="number">4.</span>查询</span><br><span class="line">  moment对象.isBefore(指定的时间) 判断 如果时间对象的时间 早于 指定时间 值为<span class="literal">true</span> 否则 值为<span class="literal">false</span></span><br><span class="line">  moment(<span class="string">&#x27;2010-10-20&#x27;</span>).isBefore(<span class="string">&#x27;2010-12-31&#x27;</span>, <span class="string">&#x27;year&#x27;</span>)<span class="comment">//如果传入第二个参数 表示比较的具体时间</span></span><br><span class="line">  moment对象.isAfter(指定时间) 判断 如果时间对象的时间 晚于 指定时间 值为<span class="literal">true</span> 否则 值为<span class="literal">false</span></span><br><span class="line">  moment对象.isBetween(指定时间<span class="number">1</span>，指定时间<span class="number">2</span>) 判断 如果时间对象的时间 在 两个指定时间之间 值为<span class="literal">true</span> 否则 值为<span class="literal">false</span></span><br><span class="line">  moment().isLeapYear();<span class="comment">//判断当前时间对象 是不是闰年</span></span><br></pre></td></tr></table></figure><h2 id="String对象-熟练掌握"><a href="#String对象-熟练掌握" class="headerlink" title="String对象    熟练掌握"></a>String对象    熟练掌握</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在js中 一切皆对象 </span><br><span class="line"><span class="number">2.</span>字符串的创建方式</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;xxxx&quot;</span>;  字面量创建字符串</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="built_in">String</span>(<span class="string">&quot;xxxx&quot;</span>);  </span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;xxxx&quot;</span>); 实例化创建字符串</span><br><span class="line"><span class="number">3.</span>字符串对象 也是 js中的 内置对象  具备很多方法 用来操作字符串</span><br><span class="line">length:字符串的长度  就是 字符串中 包含字符的个数</span><br><span class="line">charAt:字符串.charAt(下标)  用来获取字符串中 指定下标的 字符</span><br><span class="line">chartCodeAt:字符串.charCodeAt(下标) 用来获取字符串中 指定下标 字符 对应的 ASCII码 a-z <span class="number">97</span>-<span class="number">122</span> 了解</span><br><span class="line"><span class="number">4.</span>indexOf </span><br><span class="line">  用法<span class="number">1</span> : 字符串.indexOf(指定字符或字符片段)</span><br><span class="line">  作用 : 获取指定字符 或 字符片段 在字符串中 第一次 出现时的下标 如果指定的字符未出现 返回值为-<span class="number">1</span></span><br><span class="line">  用法<span class="number">2</span> : 字符串.indexOf(指定字符或字符片段,指定起始下标);</span><br><span class="line">  作用 : 从指定起始下标开始 向后查找指定的字符  如果找到 就返回指定字符第一次出现 下标，如果没找到  就返回-<span class="number">1</span></span><br><span class="line"><span class="number">5.</span>lastIndexOf</span><br><span class="line">  用法和作用都和indexOf完全相同  只不过  本方法 是从后往前查找</span><br><span class="line"><span class="number">6.</span>字符串比较大小  了解</span><br><span class="line">  将两个字符串按位进行比较 用每一位的unicode编码值进行比较  一旦某一位比出大小 后面的 就不比了</span><br><span class="line"><span class="number">7.</span>截取字符串的方法  熟练掌握</span><br><span class="line">  slice  字符串.slice(起始下标，结束下标)</span><br><span class="line">          作用 : 在字符串中 从起始下标开始  到结束下标结束  截取出中间的内容</span><br><span class="line">          注意 : 能取到开头 取不到结尾</span><br><span class="line">         </span><br><span class="line">         字符串.slice(起始下标)  从起始下标 一直 截取到 字符串末尾</span><br><span class="line">  substring  用法和作用及注意事项 同上</span><br><span class="line">  </span><br><span class="line">  slice 和 substring 的区别</span><br><span class="line">  <span class="number">1.</span>如果起始下标和结束下标顺序传反了:</span><br><span class="line">slice : 直接截取不到;</span><br><span class="line">    substring : 会自动将顺序调整正确 之后截取  容错率较高 适合新手使用</span><br><span class="line">  <span class="number">2.</span>如果传入负数参数 : </span><br><span class="line">    slice : 会先给负数参数 加上 字符串的长度 加完之后的结果如果是正数或<span class="number">0</span> 就直接使用  如果加完之后   还是负数 就直接置零   </span><br><span class="line">    substring : 直接置零</span><br><span class="line"><span class="number">8.</span> 大小写转换方法</span><br><span class="line">   字符串中所有字母转大写: 字符串.toUpperCase();</span><br><span class="line">   字符串中所有字母转小写: 字符串.toLowerCase();</span><br><span class="line"><span class="number">9.</span>字符串的切割方法</span><br><span class="line">  用法<span class="number">1</span>：字符串.split()  作用：直接将整个字符串 作为数组项 存入数组中 并返回数组</span><br><span class="line">  用法<span class="number">2</span>：字符串.split(<span class="string">&quot;切割标识&quot;</span>)  作用：在切割标识位置下刀 将字符串切分为多部分，最后将每一部分作       为数组项 存入数组中 并返回数组</span><br><span class="line">        注意：切割标识  最后会被切掉  </span><br><span class="line">  用法<span class="number">3</span>：字符串.split(<span class="string">&quot;切割标识&quot;</span>,数字) 作用：切割字符串为数组 数组长度不能超过指定的数字</span><br><span class="line"><span class="number">10.</span>字符串的替换方法</span><br><span class="line">   用法：字符串.replace(<span class="string">&quot;要被替换的内容&quot;</span>,<span class="string">&quot;用来替换的内容&quot;</span>);</span><br><span class="line">   作用：使用  用来替换的内容  替换  要被替换的内容</span><br><span class="line"><span class="number">11.</span>字符串去除两端空格的方法</span><br><span class="line">   用法：字符串.trim();</span><br><span class="line">   作用：删除字符串两端的空格</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时器</title>
      <link href="2021/05/02/6-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>2021/05/02/6-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>定义：JavaScript提供了一些原生方法来实现延时去执行某一段代码 的功能—定时器</p><h2 id="定时器分类"><a href="#定时器分类" class="headerlink" title="定时器分类"></a>定时器分类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">setTimeout</span></span><br><span class="line">  用法 : <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 要延迟执行的代码 &#125;,延迟时间)</span><br><span class="line">  作用 : 延迟指定的时间 之后 执行函数中的代码</span><br><span class="line">  注意 : 延迟时间 单位为 ms  1s===1000ms  在定时器中 写时间 不加单位</span><br><span class="line">  实例 : <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="number">1000</span>)  表示延迟1s执行函数</span><br><span class="line"><span class="number">2.</span>间歇定时器</span><br><span class="line">  <span class="built_in">setInterval</span></span><br><span class="line">  用法 : <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 要间歇执行的代码 &#125;,间歇时间)</span><br><span class="line">  作用 : 每隔指定的时间 执行一次函数</span><br><span class="line">  注意 : 间歇时间 单位为 ms  1s===1000ms  在定时器中 写时间 不加单位</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="清除定时器"><a href="#清除定时器" class="headerlink" title="清除定时器"></a>清除定时器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定时器id : 定时器就是一个函数  是函数 就有返回值  这个返回值我们称为 定时器的id  定时器id就是一个数字  从<span class="number">1</span>开始 按照定时器在代码中出现的顺序 排序   定时器id是唯一的  因此定时器id可以代表这个定时器</span><br><span class="line"><span class="number">1.</span>清除延迟定时器</span><br><span class="line">  用法 : <span class="built_in">clearTimeout</span>(要清除的定时器id)</span><br><span class="line">  作用 : 清除指定的延迟定时器  被清除的延迟定时器 将不会执行</span><br><span class="line"><span class="number">2.</span>清除间歇定时器</span><br><span class="line">  用法 : <span class="built_in">clearInterval</span>(要清除的定时器id)</span><br><span class="line">  作用 : 清除指定的间歇定时器  被清除的间歇定时器 将不会执行</span><br><span class="line">  注意 : 清除间歇定时器  只是  下一次不执行了  本次定时器的内容还是要执行完的</span><br></pre></td></tr></table></figure><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js是一门基于对象的语言  因此 js中自带了 很多对象  可以帮助用户处理一些简单的功能</span><br><span class="line">js中自带的对象 比较常用的 有四个 <span class="built_in">Math</span>对象、string对象、array对象、<span class="built_in">Date</span>对象</span><br><span class="line"><span class="built_in">Math</span>对象 是用来处理 数学相关问题的 对象  </span><br><span class="line">这个对象中 有很多方法函数  可以用来处理 不同的数学问题</span><br><span class="line"><span class="built_in">Math</span>对象方法的用法 : <span class="built_in">Math</span>.方法名();</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>求一组数中 最大最小值  max/min   不能求数组中的最大最小值</span><br><span class="line">  用法 : <span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,...)/<span class="built_in">Math</span>.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,...)</span><br><span class="line"><span class="number">2.</span>给数字向上向下取整   ceil/floor </span><br><span class="line">  用法 : <span class="built_in">Math</span>.ceil(要取整的数字)/<span class="built_in">Math</span>.floor(要取整的数字)</span><br><span class="line"><span class="number">3.</span>乘方和开平方</span><br><span class="line">  乘方 : pow   </span><br><span class="line">  用法 : <span class="built_in">Math</span>.pow(x,y)  </span><br><span class="line">  作用 : 得到x的y次方</span><br><span class="line">  </span><br><span class="line">  开平方 : sqrt</span><br><span class="line">  用法 : <span class="built_in">Math</span>.sqrt(要开平方的数字)</span><br><span class="line">  作用 : 得到开平方后的结果</span><br><span class="line"><span class="number">4.</span>四舍五入  round</span><br><span class="line">  用法 : <span class="built_in">Math</span>.round(要四舍五入的数字)</span><br><span class="line">  四舍五入只针对 小数  只要不够<span class="number">0.5</span> 就不进位 </span><br><span class="line"><span class="number">5.</span>绝对值  abs</span><br><span class="line">  用法 : <span class="built_in">Math</span>.abs(要求绝对值的数字)</span><br><span class="line"><span class="number">6.</span>随机数 random</span><br><span class="line">  用法 : <span class="built_in">Math</span>.random()</span><br><span class="line">  作用 : 可以得到 [<span class="number">0</span>,<span class="number">1</span>) 之间 的 随机数</span><br><span class="line">random : </span><br><span class="line">获取 <span class="number">0</span>-n  范围 的 随机数    <span class="built_in">Math</span>.random() * n</span><br><span class="line">获取 m-n  范围 的 随机数    <span class="built_in">Math</span>.random() * (n-m) + m</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数高级</title>
      <link href="2021/05/01/5-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/"/>
      <url>2021/05/01/5-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h1><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>1.this</p><p>​    定义：this的指向( 值 ) 是 包含this的函数 所属于的  对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  对象的方法函数 中 <span class="built_in">this</span> 指向 调用方法 的 对象</span><br><span class="line">obj.say()</span><br><span class="line"></span><br><span class="line">元素对象.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125; 事件处理函数 中 <span class="built_in">this</span> 指向 添加事件的元素</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有声明在script标签中的 变量 和 函数 都会作为 window对象的 属性 和 方法 存在</span></span><br><span class="line">函数名()</span><br><span class="line"><span class="built_in">window</span>.函数名()</span><br><span class="line">普通函数 中 <span class="built_in">this</span> 指向 <span class="built_in">window</span>对象</span><br><span class="line"></span><br><span class="line">自定义属性的使用情况：当每一个元素都要有一个变量的时候  就可以使用自定义属性</span><br><span class="line">自定义索引的使用情况：当<span class="keyword">for</span>循环嵌套事件时 循环变量 在事件中不能使用 就可以使用自定义索引来记录下标</span><br><span class="line">用法：元素.自定义属性名 = 属性值</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>arguments 和 形参的关系    了解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果<span class="built_in">arguments</span>发生变化  形参 会 发生相应的变化</span><br><span class="line"><span class="number">2.</span>如果形参发生变化  <span class="built_in">arguments</span> 会 发生相应的变化</span><br></pre></td></tr></table></figure><p>参数的特殊情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果 形参个数 多于 实参  实参会按照顺序 给 形参赋值  后面多出来的形参  就没有值  也就是<span class="literal">undefined</span></span><br><span class="line"><span class="number">2.</span>如果 实参个数 多于 形参  实参会按照顺序 给 形参赋值  后面多出来的实参  就直接舍弃掉</span><br></pre></td></tr></table></figure><p>参数的数据类型：js中所有数据类型的数据 都可以做 函数的实参</p><h1 id="函数高级-1"><a href="#函数高级-1" class="headerlink" title="函数高级"></a>函数高级</h1><h2 id="作用域-熟练掌握"><a href="#作用域-熟练掌握" class="headerlink" title="作用域    熟练掌握"></a>作用域    熟练掌握</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义 : 就是变量和函数的有效使用范围， 分为 全局作用域 和 局部作用域</span><br><span class="line">全局作用域 : script标签内部直接包裹的代码空间</span><br><span class="line">&lt;script&gt;</span><br><span class="line">全局作用域    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">局部(函数)作用域 : 函数大括号内部包裹的代码空间</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名 (<span class="params"></span>)</span>&#123;</span><br><span class="line">    局部作用域</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">全局变量 : 在全局作用域中 声明 的 变量  就是全局变量 有效适用范围 为 全局作用域</span><br><span class="line">  全局变量哪都能用</span><br><span class="line">局部变量 : 在局部作用域中 声明 的 变量  就是局部变量 有效使用范围 为 局部作用域</span><br><span class="line">  局部变量只在局部作用域范围内可使用</span><br><span class="line">        </span><br><span class="line">作用域链 : 当我们使用一个变量的时候 会先在当前作用域查找是否声明过这个变量，如果声明过，就直接使用， 如果没声明过  会向上一级作用域中查找，如果声明了 就使用 如果没声明 就继续向上一级作用域查 找，一直找到全局作用域，如果声明过 就可以使用  如果没声明过  就报错</span><br><span class="line"></span><br><span class="line">  如果内层作用域中和外层作用域中有重名变量  优先使用内层作用域中的变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">定义 : 在每一个作用域中  js代码要执行之前  会先执行预解析  预解析分为两步</span><br><span class="line">  <span class="number">1.</span>遍历当前作用域中的所有js代码  查找 变量声明(<span class="keyword">var</span> 变量名) 和 函数声明(<span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">  <span class="number">2.</span>将 变量声明 和 函数声明 提升到 当前作用域的最顶端</span><br><span class="line">在预解析执行完之后 才会开始执行 js代码</span><br><span class="line"></span><br><span class="line">拓展 : 在js中 如果函数和变量重名  函数覆盖变量</span><br><span class="line">注意 : 如果在函数中 写入形参 并传入实参  函数调用时 会先进行预解析 提升变量和函数声明，之后先给形参赋值为实参， 之后再执行js代码</span><br><span class="line">预解析---&gt;形参=实参---&gt;js代码从上到下执行</span><br><span class="line"></span><br><span class="line">简答类型数据 和 复杂类型数据 在赋值时的区别</span><br><span class="line"><span class="number">1.</span>简单类型数据 赋值  就是直接传递值</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;  <span class="keyword">var</span> b = a;  表示 将a变量的值<span class="number">10</span>  赋值给 b变量</span><br><span class="line"><span class="number">2.</span>复杂类型数据 赋值  是将自身的地址 传递给别的变量</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;xxx&quot;</span>&#125;;  <span class="keyword">var</span> obj1 = obj; 表示 将obj对象的地址  赋值给obj1变量</span><br><span class="line"></span><br><span class="line">因此 简单类型 也被称为 值类型    复杂类型 也被称为  引用类型</span><br></pre></td></tr></table></figure><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>函数的返回值</span><br><span class="line">写法 : 在函数中  写入  关键字 <span class="keyword">return</span> 要返回的数据或变量  即可将该数据或变量 返回出函数  函数外面就可以使用了</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;<span class="comment">//将a 返回出函数  在函数外面 可以使用了</span></span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">//这个fn()===fn函数的返回值</span></span><br><span class="line">注意：函数调用表达式 的值 就是 函数的返回值</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>返回值的细节问题</span><br><span class="line">  每一个函数 都有自己的 返回值  如果没写<span class="keyword">return</span>关键字  默认返回 <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> 关键字 除了用来返回数据之外 还有 结束函数执行的功能。  <span class="keyword">return</span> 写在哪里 函数就在哪里结束执   行</span><br><span class="line">  <span class="keyword">return</span> 只能返回一个数据 如果想返回多个数据  可以使用数组来做</span><br><span class="line"><span class="number">3.</span>返回值的数据类型  了解</span><br><span class="line">  js中函数的返回值 可以是 任意类型数据</span><br></pre></td></tr></table></figure><h2 id="获取元素样式"><a href="#获取元素样式" class="headerlink" title="获取元素样式"></a>获取元素样式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>获取元素的行内样式</span><br><span class="line">元素.style.样式属性名</span><br><span class="line"><span class="number">2.</span>获取非行内样式的方法</span><br><span class="line">getComputedStyle  标准浏览器的方法</span><br><span class="line">用法 : <span class="built_in">window</span>.getComputedStyle(要获取样式的元素).样式属性名  <span class="built_in">window</span>可以省略</span><br><span class="line">作用 : 获取指定元素 的 指定样式（包括行内 和 非行内 样式）</span><br><span class="line">有兼容性问题 ie8及以下浏览器  不支持该方法</span><br><span class="line"></span><br><span class="line">currentStyle  IE自己的方法</span><br><span class="line">用法 : 要获取样式的元素.currentStyle.样式属性名</span><br><span class="line">作用 : 获取指定元素 的 非行内样式(行内样式无法获取)</span><br><span class="line"></span><br><span class="line">获取元素非行内样式的兼容写法</span><br><span class="line"><span class="comment">//在标准浏览器中 元素.currentStyle 值为 undefined</span></span><br><span class="line"><span class="comment">//在IE8及以下浏览器中  getComputedStyle 不存在</span></span><br><span class="line"><span class="keyword">if</span>(div.currentStyle==<span class="literal">undefined</span>)&#123;</span><br><span class="line">            <span class="comment">//证明在标准浏览器中  就使用 getComputedStyle 获取</span></span><br><span class="line">            <span class="built_in">console</span>.log(getComputedStyle(div).width);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//证明在ie8及以下浏览器中 就使用currentStyle</span></span><br><span class="line">            <span class="built_in">console</span>.log(div.currentStyle.width);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this和自定义属性</title>
      <link href="2021/05/01/4-this%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
      <url>2021/05/01/4-this%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="this和自定义属性"><a href="#this和自定义属性" class="headerlink" title="this和自定义属性"></a>this和自定义属性</h1><p>1.while类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span></span><br><span class="line">    语法 :</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>; <span class="comment">//初始化循环变量</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">5</span>(循环条件))&#123;</span><br><span class="line">        <span class="comment">//循环体代码</span></span><br><span class="line">        i++ <span class="comment">//更新循环变量</span></span><br><span class="line">    &#125;</span><br><span class="line">不推荐使用<span class="keyword">while</span></span><br><span class="line"><span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line">语法 : </span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>;<span class="comment">//初始化循环变量</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//循环体代码</span></span><br><span class="line">        <span class="comment">//更新循环变量</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(循环条件)</span><br><span class="line">  执行顺序</span><br><span class="line">  <span class="number">1.</span>初始化循环变量  <span class="number">2.</span>执行循环体代码  <span class="number">3.</span>更新循环变量  <span class="number">4.</span>判断循环条件</span><br><span class="line">  <span class="comment">//while和do-while的区别</span></span><br><span class="line">  <span class="keyword">while</span> 如果条件成立 执行  如果不成立 就不执行</span><br><span class="line">  <span class="keyword">do</span>-<span class="keyword">while</span>  不管条件成立与否  都可以执行一次 如果成立 继续循环  如果不成立 就结束循环</span><br></pre></td></tr></table></figure><p>2.其他结构流程控制语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> 打断 </span><br><span class="line">语法 : <span class="keyword">break</span>;</span><br><span class="line">作用 : 打断(彻底结束)当前流程控制语句的执行</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;</span><br><span class="line">上述代码 只能打印出 <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">continue</span> 继续</span><br><span class="line">语法 : <span class="keyword">continue</span>;</span><br><span class="line">作用 : 跳过本次循环，进入下一次循环</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>的定义 : <span class="built_in">this</span> 指向 包含<span class="built_in">this</span>的函数所属的对象   <span class="built_in">this</span>一般在函数中使用</span><br><span class="line"></span><br><span class="line">对象的方法函数</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">&quot;allen&quot;</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;我爱你，塞北的雪&quot;</span>) &#125; <span class="comment">//方法</span></span><br><span class="line">    <span class="comment">//当一个属性的值 是函数的时候  我们就说 这个属性  是对象的一个 方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象的方法函数的调用方式</span></span><br><span class="line">对象.方法名()</span><br><span class="line"></span><br><span class="line">事件处理函数</span><br><span class="line">元素.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 事件触发时 浏览器执行的反馈代码 &#125;</span><br><span class="line"></span><br><span class="line">普通函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>) &#125;;</span><br><span class="line">函数名()</span><br><span class="line"><span class="built_in">window</span>对象(js的顶级对象)的特殊性 : 我们声明在script标签中的所有变量 和 函数 都会作为<span class="built_in">window</span>对象的属性 和 方法存在</span><br><span class="line">这些声明在script标签中的变量 和 函数 既可以直接使用  也可以作为 <span class="built_in">window</span>对象的属性和方法使用</span><br><span class="line">函数名()</span><br><span class="line"><span class="built_in">window</span>.函数名()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给元素对象 添加 自定义属性</span><br><span class="line">写法 : 元素对象.属性名 = 属性值</span><br><span class="line">获取元素对象自定义属性值</span><br><span class="line">写法 : 元素对象.属性名</span><br><span class="line"></span><br><span class="line">注意 : 给元素添加自定义属性之后  并不会在 元素上看到  但获取 可以获取到对应的属性值</span><br><span class="line"></span><br><span class="line">自定义索引</span><br><span class="line">当我们使用 自定义属性记录 元素的下标  我们就称 这种自定义属性 为 自定义索引</span><br><span class="line"></span><br><span class="line">排他思想</span><br><span class="line"><span class="number">1.</span>干掉所有人</span><br><span class="line"><span class="number">2.</span>复活我自己</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>关键字声明   熟练运用</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123; 代码 &#125;</span><br><span class="line">函数名()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>字面量声明   熟练运用</span><br><span class="line"><span class="keyword">var</span> 变量名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    代码</span><br><span class="line">&#125;</span><br><span class="line">变量名()</span><br></pre></td></tr></table></figure><h3 id="函数的使用范围"><a href="#函数的使用范围" class="headerlink" title="函数的使用范围"></a>函数的使用范围</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>函数可以用来做事件处理函数  </span><br><span class="line"><span class="number">2.</span>函数可以将一个功能的代码封装起来，防止外部代码影响</span><br><span class="line"><span class="number">3.</span>函数可以作为对象的方法来使用</span><br><span class="line"><span class="number">4.</span>函数可以实现代码的复用（重复使用）</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的参数</span></span><br><span class="line">作用 : 给函数内部  传入一些 必须的 原材料</span><br><span class="line">分类 : </span><br><span class="line"><span class="number">1.</span>形式参数</span><br><span class="line">    写法 : <span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>,形参<span class="number">2</span>,...</span>)</span>&#123;&#125;</span><br><span class="line">    在函数中  写入形参  就相当于  在函数中 声明了变量   形参命名需要符合变量命名规则</span><br><span class="line">        形参值默认为<span class="literal">undefined</span></span><br><span class="line">    <span class="number">2.</span>实际参数</span><br><span class="line">    写法：函数名(实参<span class="number">1</span>,实参<span class="number">2</span>,...)</span><br><span class="line">        在函数调用中  传入实参  相当于  给函数中声明的形参赋值  赋值按照顺序进行</span><br><span class="line"></span><br><span class="line">特殊情况：当参数的个数不确定的时候  形参和实参系统 就失效了  这时 我们可以使用<span class="built_in">arguments</span>来获取到实际参数</span><br><span class="line"><span class="built_in">arguments</span></span><br><span class="line">作用：<span class="built_in">arguments</span>是实参列表  是一个伪数组  其中包含所有传入函数中的  实际参数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js流程控制语句</title>
      <link href="2021/05/01/3-js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>2021/05/01/3-js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="js流程控制语句"><a href="#js流程控制语句" class="headerlink" title="js流程控制语句"></a>js流程控制语句</h1><h2 id="流程控制语句分类"><a href="#流程控制语句分类" class="headerlink" title="流程控制语句分类"></a>流程控制语句分类</h2><p>1.顺序结构流程控制语句：js代码 按照从上到下的顺序 执行</p><p>2.选择结构流程控制语句</p><p>​    if类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">if</span>流程控制语句  做判断</span><br><span class="line">语法 : <span class="keyword">if</span>(判断条件)&#123; 条件成立执行的代码 &#125;</span><br><span class="line">简写形式 : <span class="keyword">if</span>(判断条件) 条件成立执行的代码  <span class="keyword">if</span>只能控制其后的第一句代码</span><br><span class="line"><span class="number">2.</span><span class="keyword">if</span>-<span class="keyword">else</span>   做判断</span><br><span class="line">语法 : <span class="keyword">if</span>(判断条件)&#123; 条件成立执行的代码 &#125; <span class="keyword">else</span>&#123; 条件不成立执行的代码 &#125;</span><br><span class="line"><span class="number">3.</span><span class="keyword">if</span>-<span class="keyword">else</span> 的嵌套  如果我们需要同时满足多个条件  这时就需要使用<span class="keyword">if</span>的嵌套</span><br><span class="line">一般我们不推荐使用  因为性能不好  我们可以使用与运算来替代</span><br><span class="line"><span class="number">4.</span><span class="keyword">if</span>-<span class="keyword">else</span> 多分支语句  当需要进行多种情况的判断时 需要使用多分支语句</span><br><span class="line">语法 : <span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123; 条件成立执行的代码 &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123; 条件<span class="number">1</span>不成立但条件<span class="number">2</span>成立执行的代码 &#125;</span><br><span class="line">  ......</span><br><span class="line">      <span class="keyword">else</span>&#123; 前面所有条件都不成立执行的代码 &#125;</span><br><span class="line">由于性能不好，因此我们并不建议使用<span class="keyword">if</span>-<span class="keyword">else</span>多分支语句</span><br></pre></td></tr></table></figure><p>​    switch类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法 : <span class="keyword">switch</span>(匹配常量)&#123; </span><br><span class="line">    <span class="keyword">case</span> 匹配项<span class="number">1</span> ：匹配成功执行的代码；<span class="keyword">break</span>； </span><br><span class="line">        <span class="keyword">case</span> 匹配项<span class="number">2</span> ：匹配成功执行的代码；<span class="keyword">break</span>；</span><br><span class="line">        <span class="keyword">case</span> 匹配项<span class="number">3</span> ：匹配成功执行的代码；<span class="keyword">break</span>；</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">default</span>：前面所有匹配项都匹配失败 执行的代码;</span><br><span class="line">  &#125;</span><br><span class="line">工作原理：使用 匹配常量 和每一个匹配项 依次进行比较  如果和某一个匹配项全等  就匹配成功 执行后面的 代码</span><br></pre></td></tr></table></figure><p>3.循环结构流程控制语句</p><p>for类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环</span><br><span class="line">语法 : <span class="keyword">for</span>(初始化循环变量; 循环条件; 更新循环变量)&#123; 循环执行的代码 &#125;</span><br><span class="line">循环执行的效果：如果满足循环条件 就循环执行&#123;&#125;中的代码  直到不满足循环条件为止</span><br><span class="line"></span><br><span class="line">浏览器断点调试</span><br><span class="line"><span class="number">1.</span>打开开发者工具 选择Sources</span><br><span class="line"><span class="number">2.</span>在源代码中 插入 断点 </span><br><span class="line"><span class="number">3.</span>选择并添加  需要检测的数据</span><br><span class="line"><span class="number">4.</span>在加好断点 并添加完监听数据 之后 刷新页面</span><br><span class="line"><span class="number">5.</span>在使用完断点调试之后 要清除断点</span><br><span class="line"></span><br><span class="line"><span class="comment">//for循环代码执行过程</span></span><br><span class="line">        <span class="comment">//1.初始化循环变量 var i=0 1 2 3 4 5;</span></span><br><span class="line">        <span class="comment">//2.判断循环条件 i&lt;5 如果成立 就往下走 如果不成立就结束循环</span></span><br><span class="line">        <span class="comment">//3.执行循环体代码 打印0 1 2 3 4</span></span><br><span class="line">        <span class="comment">//4.更新循环变量 i++ </span></span><br><span class="line">        <span class="comment">//5.回到第2步继续执行</span></span><br><span class="line"></span><br><span class="line">获取元素的新方法</span><br><span class="line"><span class="number">1.</span>getElementsByTagName  通过标签名 获取元素</span><br><span class="line">用法：<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;标签名&quot;</span>)</span><br><span class="line">本方法 获取到的结果 是所有满足条件的元素集合（也称为 伪数组） 特性和数组一样</span><br><span class="line">length属性表示包含的元素个数</span><br><span class="line">也可以通过下标获取对应的元素  元素集合[下标] </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>getElementsByClassName  通过类名 获取元素</span><br><span class="line">用法：<span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;类名&quot;</span>)</span><br><span class="line">得到的也是一个元素集合（伪数组）</span><br><span class="line"></span><br><span class="line">getElementsByTagName、getElementsByClassName和getElementById 的区别</span><br><span class="line"><span class="number">1.</span>前两者 获取到的都是 伪数组  而后者获取到的是 元素</span><br><span class="line"><span class="number">2.</span>获取范围不同  byId 只能使用 <span class="built_in">document</span> 作为范围</span><br><span class="line">  byTagName和byClassName则可以使用  <span class="built_in">document</span>和父元素作为范围</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"><span class="keyword">for</span>-<span class="keyword">in</span> 循环</span><br><span class="line">作用 : <span class="keyword">for</span>-<span class="keyword">in</span> 循环 是专门用来循环对象的</span><br><span class="line">语法 : <span class="keyword">for</span>(<span class="keyword">var</span> 属性名变量 <span class="keyword">in</span> 要循环的对象)&#123; 循环体代码 &#125;</span><br><span class="line">解释 : 属性名变量 在<span class="keyword">for</span>-<span class="keyword">in</span>循环中  就表示  对象中的属性名</span><br><span class="line">执行逻辑 : <span class="keyword">for</span>-<span class="keyword">in</span> 循环 是一种自动循环  对象有多少属性  <span class="keyword">for</span>-<span class="keyword">in</span> 就寻循环多少次  每循环一次 就执行一  次循环体代码</span><br><span class="line">获取属性值 : 对象.属性名</span><br><span class="line">注意：在 <span class="keyword">for</span>-<span class="keyword">in</span>  循环中 不能使用 对象.属性名变量 的形式 获取属性值 因为.的形式要求后面的属性名必须切实存在   在 <span class="keyword">for</span>-<span class="keyword">in</span> 中我们需要使用  对象[属性名变量] 来获取属性值</span><br></pre></td></tr></table></figure><p>while类</p><p>4.其他流程控制语句</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的数据类型 和 类型转换 及 运算符</title>
      <link href="2021/05/01/2-js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E5%92%8C%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%20%E5%8F%8A%20%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/05/01/2-js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E5%92%8C%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%20%E5%8F%8A%20%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="js的数据类型-和-类型转换-及-运算符"><a href="#js的数据类型-和-类型转换-及-运算符" class="headerlink" title="js的数据类型 和 类型转换 及 运算符"></a>js的数据类型 和 类型转换 及 运算符</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>简单（值/基本）类型数据： 熟练掌握</p><p>​    1.Number 数字   整型：整数    浮点型：小数 基本和数学中数字的概念完全相同</p><p>​            数字类型数据详解</p><p>​            1.数字类型数据分类  熟悉</p><p>​                    整型：123  -123  123.0</p><p>​                    浮点型：123.5    .5   不建议使用浮点型数据进行运算</p><p>​                    NaN：计算错误时得到NaN  NaN全拼为 Not a Number   特性：NaN不等于任何数字  NaN和任                               何数字进行运算，得到的结果都是NaN</p><p>​            2.数字类型的进制转换  了解</p><p>​                八进制：0nnnnn   注意：八进制数字中 不能出现8或比八大的数字  如果出现了，就会默认按照十                              进制计算</p><p>​                十六进制：0xnnnnn  注意：十六进制数字中 10-15使用a-f来表示</p><p>​            3.特殊的数字值   了解</p><p>​                无穷大：Infinity   </p><p>​                在js中我们可以通过除0得到这个值     n / 0     </p><p>​            4.查看数据的  数据类型  的  方法    typeof</p><p>​                用法：typeof  要查看类型的数据</p><p>​    2.String 字符串  引号包裹任何内容 得到的都是字符串 “”  “   “  ‘1234’  ‘abc’   “123-123”</p><p>​        字符串详解</p><p>​        字符串的length属性</p><p>​            用法：字符串 . length    结果是当期字符串的长度（就是字符串中包含的字符个数）</p><p>​        获取字符串中指定的字符</p><p>​            在字符串中 给每一个字符  都添加了一个编号  编号从0开始  依次递增  我们称这种编号为字符的下标          （索引）</p><p>​            用法1：字符串[ 指定字符的下标 ]  </p><p>​            注意：这种用法 在IE8-  浏览器中 无法正常工作  得到的结果是undefined</p><p>​            用法2：字符串.charAt(指定字符的下标)</p><p>​            这个方法是通用的， 没有兼容性问题</p><p>​    3.Boolean 布尔值  只有两个值  true(真)  和  false(假)  boolean多用于判断  用作判断条件。true表示判断成功，false表示判断失败  也用来表示比较结果   3&gt;4 false      4&gt;3 true</p><p>​    4.Undefined 未定义：只有一个值 undefined    表示变量声明，但未赋值</p><p>​    5.Null  值为空 ：只有一个值  null   表示 数据值为空 </p><p>​    undefined和null的区别</p><p>​    在计算机中  内存被分为  栈区 和 堆区 两部分</p><p>​    栈区特点：容量较小 但是  存储数据有序  用来存储简单类型数据（数据量比较小）</p><p>​    堆区特点：容量很大  但是  存储数据无序</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Administrator\Pictures\堆栈的概念.png" alt="堆栈的概念"></p><p>undefined就是变量声明未赋值时的  默认值</p><p>null 没有实际数据 对应的  空地址</p><p>复杂（引用）类型数据：</p><p>​    1.Array 数组</p><p>​        定义：数组是一个存储数据的容器  </p><p>​        写作：[ 数据1 , 数据2，数据3，…… ]</p><p>​        特点：在数组中 我们可以存储 任意多个数据   也可以存储任意类型数据</p><p>​        数组的length属性：表示数组长度（就是数组中包含的数据个数）</p><p>​        数组中存储的所有数据  每一个都有一个编号 这个编号从0开始  按照数据的排序依次递增 被称为数组        的下标。</p><p>​        在数组中  每一个数据  都被称为 数组项</p><p>​    2.Object  对象</p><p>​        定义：对象是一个存储数据的容器</p><p>​        写作：{ 属性名1：属性值，属性名2：属性值，…… }</p><p>​        特点：对象使用属性的形式来存储数据  每一个属性可以存储一个数据  不同属性之间用逗号隔开 </p><p>​                   可以存储任意个属性，属性值也可以是任意类型的数据。</p><p>​                   对象中，属性名不能重复</p><p>​        获取指定的属性值：对象 . 属性名</p><p>​        设置指定属性值：对象 . 属性名 = 属性值</p><p>​    3.Function 函数</p><p>​        定义：函数是用来存储代码的容器</p><p>​        写法：function 函数名 (){ 函数中存储的代码 }</p><p>​        注意：函数名  和   变量命名一样  需要符合 变量命名的规则和规范</p><p>​        注意：函数又被称为  js中的工具   存入函数中的代码  不会自行执行   需要开发者来使用一下函数  才能                   执行</p><p>​        函数的调用（使用函数）: 函数名();</p><p>​        函数不调用  不执行</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="其他类型转换为数字："><a href="#其他类型转换为数字：" class="headerlink" title="其他类型转换为数字："></a>其他类型转换为数字：</h3><p>​        Number：  Number(要转换类型的数据)</p><p>​        数字字符串—&gt;数字   非数字字符串—&gt;NaN   空格字符串、空串—&gt;0   true–&gt;1  false—&gt;0  </p><p>​        undefined–&gt;NaN    null—&gt;0</p><p>​        parseInt/parseFloat： parseInt/parseFloat(要转换类型的数据)</p><p>​        工作原理：上述两个方法  会从要转换的数据开头开始向后进行转换， 一直到遇到不能转换的位或彻底                          转换完，就停止转换。</p><p>​        parseInt是将数据转换为整型数字   如果转换出的结果有小数位  会被直接舍弃  因此此方法可以取整</p><p>​        parseFloat是将数据转换为浮点型数字   可以保留小数位</p><p>​        isNaN：isNaN(指定数据)   效果是 判断 制定数据 如果转换为数字之后  是不是NaN  如果是 值为true                       不是  值为false</p><p>​                     注意：isNaN 转换数据类型 的 方式 是Number</p><h3 id="其他类型转换为字符串"><a href="#其他类型转换为字符串" class="headerlink" title="其他类型转换为字符串"></a>其他类型转换为字符串</h3><p>​        String：String(要转换的数据)  万能转换法</p><p>​        toString：要转换的字符串.toString()  undefined 和 null不能使用</p><h3 id="其他类型转换为布尔"><a href="#其他类型转换为布尔" class="headerlink" title="其他类型转换为布尔"></a>其他类型转换为布尔</h3><p>​        Boolean ： Boolean(要转换的数据) 万能转换法</p><p>​        数字–布尔  0–false  非0—true  NaN—false</p><p>​        字符串–布尔  空串—false   非空—true</p><p>​        undefined—false   null—false</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>​        1.其他类型转数字    要转换的数据-0     要转换的数据*1      要转换的数据/1</p><p>​        2.其他类型转字符串   要转换的数据 + “”</p><p>​        3.其他类型转布尔   !!要转换的数据       在js中！表示给布尔值取反</p><p>​    在实际开发中 我们建议大家使用    隐式转换    因为对计算机而言   更节省cpu资源</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+  -   *   /   %  和数学中的逻辑完全一样</span><br><span class="line">+  如果两个加数中  没有  字符串   都会直接将两个加数 转换为数字  进行数学加法</span><br><span class="line">如果有一个加数是字符串， 就会执行字符串的拼接</span><br><span class="line">%  获取除法运算的余数</span><br><span class="line"><span class="number">3</span>%<span class="number">2</span>===<span class="number">1</span></span><br><span class="line"></span><br><span class="line">++  --  自加   自减  </span><br><span class="line">写法：n++/++n  表示n在原基础上  +<span class="number">1</span></span><br><span class="line"> n--/--n  表示n在原基础上  -<span class="number">1</span></span><br><span class="line">注意：如果++<span class="regexp">/--写在前面  表示先自加/</span>自减  后输出   但是 如果写在后面  表示先输出  后自加/自减</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=     <span class="keyword">var</span> a = <span class="number">10</span>   表示将赋值符号后面的数据<span class="number">10</span> 赋值给  前面的变量 a</span><br><span class="line">+=    a += <span class="number">10</span> &lt;===&gt; a = a + <span class="number">10</span></span><br><span class="line">-=    a -= <span class="number">10</span> &lt;===&gt; a = a - <span class="number">10</span></span><br><span class="line">*=    a *= <span class="number">10</span> &lt;===&gt; a = a * <span class="number">10</span></span><br><span class="line">/=    a /= <span class="number">10</span> &lt;===&gt; a = a / <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;  &lt;   &gt;=  &lt;=  和数学中的比较运算符完全一样</span><br><span class="line">等于：==    操作数<span class="number">1</span> == 操作数<span class="number">2</span>   这个符号的作用 是判断两个操作数是否相等  只判断值是否相等，不判断类型是否一致</span><br><span class="line">   <span class="number">123</span> == <span class="string">&quot;123&quot;</span>   <span class="number">0</span> == <span class="string">&quot;&quot;</span></span><br><span class="line">不等于：!=  比较逻辑和==完全一样 只不过 判断的是不相等</span><br><span class="line">   <span class="number">123</span> !== <span class="string">&quot;abc&quot;</span>   <span class="number">123</span> !== <span class="string">&quot;123&quot;</span></span><br><span class="line">全等：===   操作数<span class="number">1</span> === 操作数<span class="number">2</span>   这个符号用来比较两个操作数是否全等  既判断数据类型是否相同，也判断值是否相等    数据类型和值都一样的时候 才全等 否则不全等</span><br><span class="line">不全等：!==  操作数<span class="number">1</span> !== 操作数<span class="number">2</span>   这个符号用来判断 两个操作数是否不全等  如果两个操作数值不同 或   类型不一样  都不全等</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">逻辑运算 的 操作数 都是 布尔值</span><br><span class="line">与：&amp;&amp;  操作数<span class="number">1</span> &amp;&amp; 操作数<span class="number">2</span>  </span><br><span class="line">如果两个操作数  都是<span class="literal">true</span>  算式的值为<span class="literal">true</span>  只要有一个操作数是<span class="literal">false</span>  算式的值就是<span class="literal">false</span></span><br><span class="line">或：||  操作数<span class="number">1</span> || 操作数<span class="number">2</span>  </span><br><span class="line">如果两个操作数  都是<span class="literal">false</span>  算式的值为<span class="literal">false</span>  只要有一个是<span class="literal">true</span>  算式的值就是<span class="literal">true</span></span><br><span class="line">非：!   !操作数</span><br><span class="line">取反  <span class="literal">true</span> 变 <span class="literal">false</span>   <span class="literal">false</span> 变 <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="三目（三元）运算符"><a href="#三目（三元）运算符" class="headerlink" title="三目（三元）运算符"></a>三目（三元）运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三元运算符可以进行判断</span><br><span class="line">写法：判断条件 ? 条件成立执行的代码 : 条件不成立执行的代码</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a &gt; <span class="number">100</span> ? <span class="built_in">console</span>.log(<span class="string">&quot;成立&quot;</span>) : <span class="built_in">console</span>.log(<span class="string">&quot;不成立&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript初识</title>
      <link href="2021/05/01/1-javascript%E5%88%9D%E8%AF%86/"/>
      <url>2021/05/01/1-javascript%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript的初识"><a href="#javascript的初识" class="headerlink" title="javascript的初识"></a>javascript的初识</h1><h2 id="javascript初识"><a href="#javascript初识" class="headerlink" title="javascript初识"></a>javascript初识</h2><p>javascript（简称js）</p><p>1.js的历史   了解</p><p>（Netscape）网景公司  navigator    布兰登艾奇 耗时10天开发出了js。借鉴：java的管理机制，c的函数。mocha  liveScript  javascript   </p><p>​    .js是由网景公司于1993年开发的一门语言</p><p>​    .目的是用来解决人机交互（用户表单注册提交功能）</p><p>​    .由布兰登艾奇耗时10天开发出的一门语言</p><p>​    .mocha—&gt;LiveScript—&gt;JavaScript  </p><p>2.什么是js  熟悉</p><p>​    js是一门 基于对象的， 由事件驱动的， 解释性脚本语言</p><p>​    基于对象的：在js中，为了方便程序员开发，js给我们提供了很多工具，这些工具可以帮助我们实现一些                         简单的效果，这些工具就叫做对象</p><p>​    事件驱动的：js最主要的功能就是实现了浏览器和用户的交互功能，本质上，js就是通过事件这种工作机                         制来实现了人机交互功能。</p><p>​    解释性：我们编写的js代码 不是计算机语言，因此 浏览器不能直接执行这种代码，需要翻译为机器语言，                  才能执行，翻译有两种方式</p><p>​                  编译：java php c c++ c#  优点：一次编译，永久使用。</p><p>​                  解释：js  逐行解释代码，每解释一行，就执行一行。 缺点：每次都需要重新解释</p><p>3.js的组成部分 熟悉</p><p>ECMAScript ： ECMA（欧洲计算机厂商联盟） Jscript ECMAScript-262 —&gt; ES5 </p><p>​                          ECMAScript是js的一种语法规则 数据类型+变量+流程控制语句+运算符</p><p>DOM：Document Object Model  文档对象模型  是用来帮助用户操作页面html标签的</p><p>BOM：Browser Object Model   浏览器对象模型  是用来帮助用户操作浏览器的</p><p>4.js的引入方式</p><p>行内引入：将js代码作为标签属性 写入标签中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 效果：点击div的时候  页面会弹窗输出内容  我爱你，塞北的雪--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;我爱你，塞北的雪&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 这段代码是一个事件，叫做onclick(点击)事件 这段代码表示 给div标签 添加了一个点击事件，这个点击事件 要做的事情就是 alert(&#x27;我爱你，塞北的雪&#x27;)  alert的作用是在页面上弹出警告窗口，窗口提示内容为开发者输入的内容  </span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">   点击事件的触发机制为 用户点击时触发。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br></pre></td></tr></table></figure><p>一般我们不建议大家使用行内引入js，因为不利于结构层和逻辑层的分离</p><p>注意：当出现引号的嵌套情况时，内外层引号不能一样</p><p>内部引入：在html代码中 写入script标签，将js代码写在script标签中即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;script&gt;</span></span><br><span class="line"><span class="comment">js代码</span></span><br><span class="line"><span class="comment">&lt;/script&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;我爱你，中国&quot;</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：在html文件中，我们可以写入任意多个script标签，并且可以写在任意位置。</p><p>​            一般我们建议大家将script标签写在 head标签或body标签的末尾</p><p>​          执行顺序遵循html的执行顺序 从上到下，在执行过程中 如果遇到script标签，就会先进入script标签中，将其中的js代码执行完，再继续向下执行</p><p>外部引入：使用script标签的src属性 引入外部的js文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：用来引入外部js文件的script标签  内部不能写js代码  即便写了，也不会执行。</p><p>​           如果需要在内部编写js代码，可以写入一个新的script标签。</p><p>我们推荐大家使用外部引入</p><p>5.js的注释</p><p>单行文本注释：可以注释掉一行代码 如果换行 就不能注释</p><p>写法：//要注释的内容</p><p>多行文本注释：可以注释掉多行代码 即使换行 也可以注释</p><p>写法：/* 要注释的内容 */</p><p>6.js的页面加载函数 ( js的入口函数 )  熟练运用 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">js代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入window.onload并将js代码写入其中 这时 写在其中的js代码 会在  页面上的 html结构、css样式、外部引入的资源  都加载完之后  再执行。</span></span><br></pre></td></tr></table></figure><h2 id="javascript的简单操作"><a href="#javascript的简单操作" class="headerlink" title="javascript的简单操作"></a>javascript的简单操作</h2><p>1.js的变量  熟练运用</p><p>定义：变量就是值可以改变的量。变量是数据的容器</p><p>写法：</p><p>​    1.变量的声明：var 变量名                  相当于 拿来了一个空的容器</p><p>​    2.变量的赋值：变量名 = 数据（变量值）    相当于将数据作为内容  放进容器中</p><p>​    =  在js中不表示判断相等  而表示赋值 因此在js中 = 叫做赋值符号 读作赋值为</p><p>变量声明的简便写法</p><p>​     1.变量声明并赋值：var 变量名 = 数据；</p><p>​     2.变量的连续声明：var 变量名1 = 数据 ，变量名2 = 数据，…；</p><p>​     3.变量的连等：var 变量名1 = 变量名2 = 数据；</p><p>变量命名规则   熟练掌握  如果不遵守 就会报错</p><p>​      1.变量命名不能以数字开头  </p><p>​      2.变量命名不能使用  除了  _和$  之外的任何特殊字符</p><p>​      3.变量命名不能使用  关键字 和 保留字（候选关键字）</p><p>变量命名的规范   熟练掌握  规范不遵守 并不会报错</p><p>​       1.变量命名应尽量使用驼峰命名法  getElementById   userName</p><p>​       2.变量命名尽量不要使用中文</p><p>​       3.变量命名应尽量具备语义化  </p><p>2.js简单的鼠标类事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>点击事件  onclick</span><br><span class="line">元素.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当点击事件触发的时候  浏览器执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">点击事件的触发机制：当用户点击添加事件的元素，就会触发点击事件，执行反馈代码</span><br><span class="line"><span class="number">2.</span>双击事件  ondblclick</span><br><span class="line">元素.ondblclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当双击事件触发的时候  浏览器执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">双击事件的触发机制：当用户双击添加事件的元素，就会触发双击事件，执行反馈代码</span><br><span class="line"><span class="number">3.</span>鼠标移动事件  onmousemove</span><br><span class="line">元素.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当鼠标移动事件触发的时候  浏览器执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">鼠标移动事件的触发机制：当用户在添加事件的元素中移动鼠标，就会触发鼠标移动事件，执行反馈代码</span><br><span class="line">补充：<span class="built_in">console</span>.log(<span class="string">&quot;要打印的内容&quot;</span>)  效果是 在控制台的<span class="built_in">console</span>中 打印指定内容</span><br><span class="line"><span class="number">4.</span>鼠标移入事件  onmouseover/onmouseenter</span><br><span class="line">元素.onmouseover/onmouseenter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当移入事件触发时执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">触发机制：会在鼠标移入到添加事件元素里面的时候 触发该事件 执行反馈代码</span><br><span class="line"><span class="number">5.</span>鼠标移出事件   onmouseout/onmouseleave</span><br><span class="line">元素.onmouseout/onmouseleave = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当移出事件触发时执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">触发机制：会在鼠标移出到添加事件元素外面的时候 触发该事件 执行反馈代码</span><br><span class="line"><span class="number">6.</span>鼠标右击事件   oncontextmenu</span><br><span class="line">元素.oncontextmenu = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当右击事件触发时执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">触发机制：会在鼠标右击添加事件的元素时  触发事件， 并执行反馈代码</span><br><span class="line"><span class="number">7.</span>鼠标按下事件   onmousedown</span><br><span class="line">元素.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当按下事件触发时执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">触发机制：会在鼠标左键按下时  触发事件， 并执行反馈代码</span><br><span class="line"><span class="number">8.</span>鼠标抬起事件   onmouseup</span><br><span class="line">元素.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    当抬起事件触发时执行的反馈代码</span><br><span class="line">&#125;</span><br><span class="line">触发机制：会在鼠标左键抬起时  触发事件， 并执行反馈代码</span><br></pre></td></tr></table></figure><ol start="3"><li><p>js简单操作</p><ol><li><p>使用js操作元素的属性</p><ol><li>用法：<ol><li>获取指定属性值：元素 . 属性名 </li><li>设置指定属性值：元素 . 属性名 = 属性值</li><li>注意：这种操作方法  只适用于操作元素的自带属性   至于非自带属性 和 自定义属性则无法操作</li><li>特殊属性：<ol><li>class：在操作的时候 需要写作  元素.className</li><li>src：获取到的结果是当前资源的绝对路径，但设置的时候 可以使用相对路径</li></ol></li></ol></li></ol></li><li><p>使用js操作元素的内容</p><ol><li>操作普通双标签html内容    innerHTML<ol><li>用法<ol><li>元素.innerHTML  获取元素的html内容</li><li>元素.innerHTML = “xxxx”  设置元素的html内容</li></ol></li></ol></li><li>操作普通双标签文本内容  innerText<ol><li>用法<ol><li>元素.innerText  获取元素的文本内容</li><li>元素.innerText = “xxxx”  设置元素文本内容</li></ol></li></ol></li><li>操作表单元素内容  value<ol><li>用法<ol><li>表单元素.value  获取表单元素的内容</li><li>表单元素.value = “xxxx”  设置表单元素内容</li></ol></li></ol></li></ol></li><li><p>使用js操作元素的样式</p><ol><li><p>用法</p><ol><li><p>获取元素样式：元素.style.样式属性名  可以获取到对应样式的值  </p><p>注意：这种方式只能获取到行内样式</p><p>特殊样式属性：background-color  font-size 等这些中间带-的属性，在js中应写作驼峰命名法—-&gt;  backgroundColor   fontSize</p></li><li><p>设置元素样式：元素.style.样式属性名 = “属性值”</p><p>注意：这种方式只能设置行内样式</p><p>特殊样式属性：background-color  font-size 等这些中间带-的属性，在js中应写作驼峰命名法—-&gt;  backgroundColor   fontSize</p></li><li><p>设置元素样式：元素.style.cssText = “css行内样式”</p><ol><li><p>在赋值的时候   引号中写的内容  就是css行内样式的内容</p></li><li><p>注意：cssText设置的样式 会完全覆盖掉元素原本的行内样式，一般用在清空行内样式的情况</p><p>清空行内样式：元素.style.cssText = “”</p></li></ol></li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5</title>
      <link href="2021/04/27/HTML5/"/>
      <url>2021/04/27/HTML5/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li><p>新的语义元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;标签定义文档的页眉</span><br><span class="line">&lt;footer&gt;标签定义文档或节的页脚</span><br><span class="line">以上支持：谷歌5.0IE9.0火狐4.0苹果5.0欧朋11.1</span><br><span class="line"></span><br><span class="line">&lt;article&gt;标签规定独立的自包含内容&lt;&#x2F;article&gt;</span><br><span class="line">支持：谷歌6.0IE9.0火狐4.0苹果5.0欧朋11.1</span><br><span class="line"></span><br><span class="line">&lt;section&gt;标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</span><br><span class="line">支持：谷歌5.0IE9.0火狐4.0苹果5.0欧朋11.5</span><br></pre></td></tr></table></figure></li><li><p>新的表单控件，比如数字、日期、时间、日历和滑块</p></li><li><p>强大的图像支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas&gt;标签定义图形，比如图表和其他图像。标签只是图形容器，您必须使用脚本来绘制图形。</span><br><span class="line">支持：谷歌4.0IE9.0火狐2.0苹果3.1欧朋9.0</span><br><span class="line"></span><br><span class="line">&lt;svg&gt;标记定义 SVG 图形的容器。</span><br><span class="line"> SVG 有几种绘制路径、框、圆、文本和图形图像的方法。</span><br><span class="line">支持：谷歌4.0IE9.0火狐3.0苹果3.2欧朋10.1</span><br></pre></td></tr></table></figure></li><li><p>强大的多媒体支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;标签定义视频，比如电影片段或其他视频流。</span><br><span class="line">支持：谷歌4.0IE9.0火狐3.5苹果3.1欧朋11.5</span><br><span class="line">&lt;audio&gt;标签定义声音，比如音乐或其他音频流。</span><br><span class="line">支持：谷歌4.0IE9.0火狐3.5苹果4.0欧朋11.5</span><br></pre></td></tr></table></figure></li><li><p>强大的新API，比如用本地储存取代cookie</p></li></ul><h2 id="被删元素"><a href="#被删元素" class="headerlink" title="被删元素"></a>被删元素</h2><p>以下HTML4.01元素已从HTML5中删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;acronym&gt;标签定义首字母缩写。</span><br><span class="line">&lt;applet&gt;标签定义嵌入的 applet。</span><br><span class="line">&lt;basefont&gt;标签定义基准字体。该标签可以为文档中的所有文本定义默认字体颜色、字体大小和字体系列。</span><br><span class="line">&lt;big&gt;标签呈现大号字体效果。</span><br><span class="line">&lt;center&gt;对其所包括的文本进行水平居中。</span><br><span class="line">&lt;dir&gt;标签定义目录列表。</span><br><span class="line">&lt;font&gt;规定文本的字体、字体尺寸、字体颜色。</span><br><span class="line">&lt;frame&gt;标签定义 frameset 中的一个特定的窗口（框架）。</span><br><span class="line">&lt;frameset&gt;可定义一个框架集。</span><br><span class="line">&lt;noframes&gt;可为那些不支持框架的浏览器显示文本。noframes 元素位于 frameset 元素内部。</span><br><span class="line">&lt;strike&gt;标签可定义加删除线文本定义。</span><br><span class="line">&lt;tt&gt;标签呈现类似打字机或者等宽的文本效果。</span><br></pre></td></tr></table></figure><h2 id="HTML5元素定义为块级元素"><a href="#HTML5元素定义为块级元素" class="headerlink" title="HTML5元素定义为块级元素"></a>HTML5元素定义为块级元素</h2><p>HTML5定义了八个新的语义HTML元素，所有的都是块级元素。<br>在老式浏览器中为了确保有正确的行为，可以把CSS display属性设置为block。<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header,section,footer,saide,nav,main,article,figure&#123;</span><br><span class="line">  display:block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新的语义-结构元素"><a href="#新的语义-结构元素" class="headerlink" title="新的语义/结构元素"></a>新的语义/结构元素</h2><table><thead><tr><th align="left"><strong>标签</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><code>&lt;article&gt;</code></td><td align="left">定义文档内的文章。</td></tr><tr><td align="left"><code>&lt;aside&gt;</code></td><td align="left">定义页面内容之外的内容。</td></tr><tr><td align="left"><code>&lt;bdi&gt;</code></td><td align="left">定义与其他文本不同的文本方向。</td></tr><tr><td align="left"><code>&lt;details&gt;</code></td><td align="left">定义用户可查看或隐藏的额外细节。</td></tr><tr><td align="left"><code>&lt;dialog&gt;</code></td><td align="left">定义对话框或窗口。</td></tr><tr><td align="left"><code>&lt;figcaption&gt;</code></td><td align="left">定义 <code>&lt;figure&gt;</code> 元素的标题。</td></tr><tr><td align="left"><code>&lt;figure&gt;</code></td><td align="left">定义自包含内容，比如图示、图表、照片、代码清单等等。</td></tr><tr><td align="left"><code>&lt;footer&gt;</code></td><td align="left">定义文档或节的页脚。</td></tr><tr><td align="left"><code>&lt;header&gt;</code></td><td align="left">定义文档或节的页眉。</td></tr><tr><td align="left"><code>&lt;main&gt;</code></td><td align="left">定义文档的主内容。</td></tr><tr><td align="left"><code>&lt;mark&gt;</code></td><td align="left">定义重要或强调的内容。</td></tr><tr><td align="left"><code>&lt;menuitem&gt;</code></td><td align="left">定义用户能够从弹出菜单调用的命令/菜单项目。</td></tr><tr><td align="left"><code>&lt;meter&gt;</code></td><td align="left">定义已知范围（尺度）内的标量测量。</td></tr><tr><td align="left"><code>&lt;nav&gt;</code></td><td align="left">定义文档内的导航链接。</td></tr><tr><td align="left"><code>&lt;progress&gt;</code></td><td align="left">定义任务进度。</td></tr><tr><td align="left"><code>&lt;rp&gt;</code></td><td align="left">定义在不支持 ruby 注释的浏览器中显示什么。</td></tr><tr><td align="left"><code>&lt;rt&gt;</code></td><td align="left">定义关于字符的解释/发音（用于东亚字体）。</td></tr><tr><td align="left"><code>&lt;ruby&gt;</code></td><td align="left">定义 ruby 注释（用于东亚字体）。</td></tr><tr><td align="left"><code>&lt;section&gt;</code></td><td align="left">定义文档中的节。</td></tr><tr><td align="left"><code>&lt;summary&gt;</code></td><td align="left">定义 <code>&lt;details&gt;</code> 元素的可见标题。</td></tr><tr><td align="left"><code>&lt;time&gt;</code></td><td align="left">定义日期/时间。</td></tr><tr><td align="left"><code>&lt;wbr&gt;</code></td><td align="left">定义可能的折行（line-break）。</td></tr></tbody></table><h2 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;datalist&gt;</code></td><td>定义输入控件的预定义选项。</td></tr><tr><td><code>&lt;keygen&gt;</code></td><td>定义键对生成器字段（用于表单）。</td></tr><tr><td><code>&lt;output&gt;</code></td><td>定义计算结果。</td></tr></tbody></table><h2 id="HTML5-图像"><a href="#HTML5-图像" class="headerlink" title="HTML5 图像"></a>HTML5 图像</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;canvas&gt;</code></td><td>定义使用 JavaScript 的图像绘制。</td></tr><tr><td><code>&lt;svg&gt;</code></td><td>定义使用 SVG 的图像绘制。</td></tr></tbody></table><h2 id="新的媒介元素"><a href="#新的媒介元素" class="headerlink" title="新的媒介元素"></a>新的媒介元素</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;audio&gt;</code></td><td>定义声音或音乐内容。</td></tr><tr><td><code>&lt;embed&gt;</code></td><td>定义外部应用程序的容器（比如插件）。</td></tr><tr><td><code>&lt;source&gt;</code></td><td>定义 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 的来源。</td></tr><tr><td><code>&lt;track&gt;</code></td><td>定义 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 的轨道。</td></tr><tr><td><code>&lt;video&gt;</code></td><td>定义视频或影片内容。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html及css总结</title>
      <link href="2021/04/27/html%E5%8F%8Acss%E6%80%BB%E7%BB%93/"/>
      <url>2021/04/27/html%E5%8F%8Acss%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="html及css总结"><a href="#html及css总结" class="headerlink" title="html及css总结"></a>html及css总结</h1><h2 id="常见浏览器及内核"><a href="#常见浏览器及内核" class="headerlink" title="常见浏览器及内核"></a>常见浏览器及内核</h2><blockquote><p>浏览器：IE、谷歌、火狐、苹果、欧朋</p><p>内核：Trident、Blink、Gecko、Webkit、Blink</p></blockquote><h2 id="b和strong（i和em）标签的区别"><a href="#b和strong（i和em）标签的区别" class="headerlink" title="b和strong（i和em）标签的区别"></a>b和strong（i和em）标签的区别</h2><blockquote><p>b标签为一个实体标签，被包围的字符设为粗体</p><p>strong标签更加有语义化（推荐使用）</p><p>i标签为倾斜</p><p>em标签更有强调意义的倾斜</p></blockquote><h2 id="引入css的方式有几种"><a href="#引入css的方式有几种" class="headerlink" title="引入css的方式有几种"></a>引入css的方式有几种</h2><blockquote><p>（1）内嵌式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过&lt;style&gt;&lt;&#x2F;style&gt;来书写CSS代码。</span><br><span class="line">只能应用于当前网页，不能被其它网页共享。</span><br><span class="line">注意：&lt;style&gt;标记可以放在网页的任何地方，但一般放在&lt;head&gt;。</span><br></pre></td></tr></table></figure><blockquote><p>（2）外联式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过&lt;link&gt;标记来引入外部的CSS文件(.css)。</span><br><span class="line">可以被其它网页共享。</span><br><span class="line">格式：&lt;link href&#x3D;&quot;CSS的URL&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;&gt;</span><br><span class="line">注意：&lt;link&gt;标记只能放在&lt;head&gt;中</span><br></pre></td></tr></table></figure><blockquote><p>（3）行内样式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过style的属性来书写CSS代码。</span><br><span class="line">举例：&lt;p style&#x3D;&quot;font-size:24px;&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h2 id="单行文本水平垂直居中如何实现"><a href="#单行文本水平垂直居中如何实现" class="headerlink" title="单行文本水平垂直居中如何实现"></a>单行文本水平垂直居中如何实现</h2><blockquote><p>1、水平居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align:center;控制单行文字水平居中</span><br></pre></td></tr></table></figure><blockquote><p>2、垂直居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置行高，line-height:与元素高度相等的值</span><br></pre></td></tr></table></figure><h2 id="选择器优先级如何计算"><a href="#选择器优先级如何计算" class="headerlink" title="选择器优先级如何计算"></a>选择器优先级如何计算</h2><ul><li><p>选择器优先级与权值相关</p></li><li><p>基础选择器的权值：通配符选择器（0）、标签选择器（1）、class选择器（10）、id选择器（100）</p></li><li><p>复合选择器的权值是所有的单一选择器权值的累加</p></li><li><p>权值越大，优先级越高；权值相同，后写的会覆盖先写的</p></li><li><p>继承样式没有权值，权值比0小，子元素设置样式会覆盖继承样式</p></li><li><p>行间样式权值为1000，优于id选择器</p></li><li><p>!important优于行间样式</p></li></ul><h2 id="那些css属性可以继承"><a href="#那些css属性可以继承" class="headerlink" title="那些css属性可以继承"></a>那些css属性可以继承</h2><blockquote><p>1、字体系列属性</p></blockquote><p>　　font-family：字体系列</p><p>　　font-weight：字体的粗细</p><p>　　font-size：字体的大小</p><p>　　font-style：字体的风格</p><p>　　line-height：行高</p><blockquote><p>2、文本系列属性</p></blockquote><p>　　text-indent：文本缩进</p><p>　　text-align：文本水平对齐</p><p>　　color：文本颜色</p><blockquote><p>3、 list-style属性</p></blockquote><h2 id="margin-存在问题"><a href="#margin-存在问题" class="headerlink" title="margin 存在问题"></a>margin 存在问题</h2><blockquote><p>重叠问题</p></blockquote><p>问题：两格兄弟元素同时设置margin-top和margin-bottom，会重叠，取最大值。</p><p>解决方案;</p><ul><li>避免同时使用，只需要一方使用</li><li>给其中一个盒子套一个大盒子包起来，给大盒子设置overflow:hidden;形成私有区域</li></ul><blockquote><p>塌陷问题</p></blockquote><p>问题：父元素的第一个子元素设置margin-top会传递给父元素</p><p>解决方案：</p><ul><li>避免使用margin-top</li><li>给父元素设置<ul><li>podding-top:1px</li><li>border-top:1px solid red;</li><li>overflow:hidden;私有区域</li></ul></li></ul><h2 id="浮动产生的问题？清除浮动的方案？"><a href="#浮动产生的问题？清除浮动的方案？" class="headerlink" title="浮动产生的问题？清除浮动的方案？"></a>浮动产生的问题？清除浮动的方案？</h2><blockquote><p>浮动元素引起的问题：</p></blockquote><p>浮动元素脱离文档流之后在文档流中不占位，父元素的高度无法被撑开，影响与父元素同级的元素</p><blockquote><p>清楚浮动的方法：</p></blockquote><p>（1）给父级元素加高度（不推荐使用，它只适合高度固定的布局，一般父盒子都是为由内容撑起来）</p><p>（2）在浮动元素的结尾处添加空div标签clear:both。具体做法：添加一个div标签并定义一个clear的类名，给clear类名添加样式clear:both，将该div标签放到父元素内容结束前的位置（缺点：会多加CSS和HTML标签）。</p><p>（3）给父级元素定义 overflow:hidden（推荐使用，缺点：不能和position配合使用，因为超出的尺寸的会被隐藏）</p><p>（4）给父级div定义伪类：after和zoom（推荐使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">清除浮动代码*&#x2F; .clearfix:after&#123;content:&quot;&quot;;display:block;clear:both;visibility:hidden;height:0&#125; .clearfix&#123;zoom:1&#125;</span><br></pre></td></tr></table></figure><p>然后父级元素添加clearfix类名即可</p><p>（5）给父级元素添加浮动（缺点：会产生新的浮动问题）</p><h2 id="BFC规则特性，及解决的问题？"><a href="#BFC规则特性，及解决的问题？" class="headerlink" title="BFC规则特性，及解决的问题？"></a>BFC规则特性，及解决的问题？</h2><blockquote><p>BFC规则</p></blockquote><ul><li><p>我的理解是：只有块级元素参与，BFC是指块级元素在页面中如何排列，如何渲染，并且与内部元素无关-</p></li><li><p>内部的标签会在垂直方向上一个接一个的放置</p><p>垂直方向上的距离由margin决定，属于同一个BFC的两个相邻标签的margin会发生重叠</p><p>每个标签的左外边距与包含块的左边界相接触（从左向右），即使浮动标签也是如此。</p><p>BFC的区域不会与float的标签区域重叠</p><p>计算BFC的高度时，浮动子标签也参与计算</p><p>BFC就是页面上的一个隔离的独立容器，容器里面的子标签不会影响到外面标签，反之亦然</p></li></ul><blockquote><p>BFC解决的问题</p></blockquote><h4 id="解决外边距折叠"><a href="#解决外边距折叠" class="headerlink" title="解决外边距折叠"></a>解决外边距折叠</h4><p>特性的第②条：垂直方向上的距离由margin决定。在常规文档流中，两个兄弟盒子之间的垂直距离是由他们的外边距所决定的，但不是他们的两个外边距之和，而是以较大的为准。特性的第⑥条：bfc就是页面上的一个独立容器，容器里面的子标签不会影响外面标签，同样外面的标签不会影响到BFC内的标签。所以可以让其中的一个标签处于一个BFC中</p><h4 id="自适应两栏或三栏布局"><a href="#自适应两栏或三栏布局" class="headerlink" title="自适应两栏或三栏布局"></a>自适应两栏或三栏布局</h4><p>左边固定宽度，右边不设宽，因此右边的宽度自适应，随浏览器窗口大小的变化而变化。</p><p>左右两边固定宽度，中间不设宽，因此中间的宽度自适应，随浏览器的大小变化而变化。</p><p>浮动的标签会覆盖正常标签根据第④条规则，BFC的区域不会与float的标签区域重叠，</p><p>所以我们只需要创建一个BFC，它就会自动缩小，以不被浮动的标签遮盖，就能够实现右侧栏自适应。</p><h4 id="防止字体环绕"><a href="#防止字体环绕" class="headerlink" title="防止字体环绕"></a>防止字体环绕</h4><p>浮动的盒子会遮盖下面的盒子，但是下面盒子里的文字是不会被遮盖的，文字反而还会环绕浮动的盒子。</p><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>利用overflow:hidden清除浮动，因为浮动的盒子无法撑出处于标准文档流的父盒子的height。根据特性第⑤条。计算BFC的高度时，浮动子标签也参与计算。</p><h2 id="图片间隙问题，如何解决"><a href="#图片间隙问题，如何解决" class="headerlink" title="图片间隙问题，如何解决"></a>图片间隙问题，如何解决</h2><p>方法 1：将图片显示为块：解决下方间隙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure><p>方法 2：改变图片的 vertical-align :解决下方间隙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">vertical-align</span>:middle; </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>除了 middle值，还可以设置为 top| bottom 等</p><p>方法 3：设置图片父级标签的 font-size:0;line-height:0; 水平间隙，图片下方间隙都能解决</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.imgwrap</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">0</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><h2 id="圣杯布局、双飞翼布局的实现原理"><a href="#圣杯布局、双飞翼布局的实现原理" class="headerlink" title="圣杯布局、双飞翼布局的实现原理"></a>圣杯布局、双飞翼布局的实现原理</h2><ul><li>圣杯布局<ul><li>HTML结构中，先主体内容后侧边</li><li>两侧宽度固定，中间宽度设置100%</li><li>两侧盒子和中间盒分别加浮动</li><li>将左侧盒子拉到最左边，将右侧盒子拉到最右边</li><li>通过左、中、右盒子的父级盒将中间内容露出来</li><li>分别还原左侧盒子和右侧盒子</li></ul></li><li>双飞翼布局<ul><li>HTML结构中，先主体结构后侧边</li><li>两侧宽度固定，中间宽度设置100%</li><li>两侧盒子和中间盒分别加浮动</li><li>将左侧盒子拉到最左边，将右侧盒子拉到最右边</li><li>在主体结构盒的子盒上设置margin值，将中间内容露出来</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/quruidong/blogFigureBed/img/20210427162150.png"></p><h2 id="精灵图的原理及优缺点？"><a href="#精灵图的原理及优缺点？" class="headerlink" title="精灵图的原理及优缺点？"></a>精灵图的原理及优缺点？</h2><p>英文叫法 css sprites，通常被解释为“CSS 图像拼合”或“CSS 贴图定位”；其实就</p><p>是把网页中一些背景图片整合到一张图片文件中，再利用 CSS “background-image”，</p><p>“background- repeat”，“background-position”的组合进行背景定位，background-position 用数字能精确的定位出背景图片的位置。适用于一般小图标，不适合大背景大布局背景</p><blockquote><p>优点：</p></blockquote><p>（1）减少网页的 http 请求，从而大大的提高页面的性能</p><p>（2）图片命名上的困扰</p><p>（3）更换风格方便</p><blockquote><p>缺点：</p></blockquote><p>（1）必须要限定容器大小符合背景图元素位置，需要计算</p><h2 id="html5的新特性"><a href="#html5的新特性" class="headerlink" title="html5的新特性"></a>html5的新特性</h2><ul><li><p>新增语义化的标签</p></li><li><p>新增表单元素和表单属性</p></li><li><p>新增网页上绘制图形的canvas元素</p></li><li><p>新增多媒体相关的video和audio</p></li><li><p>对本地离线存储的更好支持</p></li></ul><h2 id="处理HTML5新标签的浏览器兼容问题"><a href="#处理HTML5新标签的浏览器兼容问题" class="headerlink" title="处理HTML5新标签的浏览器兼容问题"></a>处理HTML5新标签的浏览器兼容问题</h2><p>HTML5新标签对IE低版本浏览器的影响及兼容情况处理方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方案一：使用javascript新增元素的方法解决</span><br><span class="line">document.createElement(“header”);</span><br><span class="line">document.createElement(“footer”);</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>由于创建出来的元素是内联元素，所以需要转换成块级，宽度和高度才能生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header,footer&#123; display:block;&#125;</span><br></pre></td></tr></table></figure><p>方案二：使用封装好的插件html5shiv.js解决兼容性问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;  src&#x3D;&quot;.&#x2F;html5shiv.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><p>上面这段代码仅会在IE浏览器下运行。</p><h2 id="响应式设计？响应式设计的基本原理？响应式优缺点？"><a href="#响应式设计？响应式设计的基本原理？响应式优缺点？" class="headerlink" title="响应式设计？响应式设计的基本原理？响应式优缺点？"></a>响应式设计？响应式设计的基本原理？响应式优缺点？</h2><p>页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。</p><p>响应式布局可以根据屏幕的大小自动的调整页面的展现方式，以及布局。响应式布局是根据设备屏幕宽度不同适当调整标签显示布局，在每种设备屏幕宽度的设备下呈现的界面是不同的。</p><blockquote><p>响应式网站的优点：</p></blockquote><ul><li><p>减少工作量 网站、设计、代码、内容都 只需要一份，多出来的工作量只是JS脚本、CSS样式做一些改变              </p></li><li><p>节省时间</p></li><li><p>每个设备都能得到正确的设计</p></li></ul><blockquote><p>响应式网站的缺点：</p></blockquote><ul><li><p>会加载更多的样式和脚本资源</p></li><li><p>设计比较难精确定位和控制</p></li><li><p>老版本浏览器兼容不好</p></li></ul><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><p>盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。</p><p>元素框的总宽度 = 元素（element）的width + padding的左边距和右边距的值 + margin的左边距和右边距的值 + border的左右宽度；</p><p>元素框的总高度 = 元素（element）的height + padding的上下边距的值 + margin的上下边距的值 ＋ border的上下宽度。</p><blockquote><p>简单来说</p><p>​    就是每一个标签所占的位置就是盒模型</p><p>盒模型的计算：</p><p>​    宽高+matgin+padding+border</p></blockquote><h2 id="使用定位实现盒子水平垂直居中的代码"><a href="#使用定位实现盒子水平垂直居中的代码" class="headerlink" title="使用定位实现盒子水平垂直居中的代码"></a>使用定位实现盒子水平垂直居中的代码</h2><p>一、定位+margin负值，盒子有宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father&#123; position:relative;&#125;</span><br><span class="line">.son&#123;position:absolute;left:50%;margin-left:-小盒子宽度的一半，top：50%；margin-top：-小盒子高度的一半&#125;</span><br></pre></td></tr></table></figure><p>二、定位+margin：auto，盒子有宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father&#123; position:relative;&#125;</span><br><span class="line">.son&#123;position:absolute;left：0；top：0；right：0；bottom：0；margin：auto&#125;</span><br></pre></td></tr></table></figure><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>LESS是一种动态语言，属于CSS预处理语言的一种,它扩展了 CSS 语言，使 CSS 更易维护和扩展,可以更便捷的进行 Web 开发，使css的编写有编程思想。</p><p>Less 包含一套自定义的语法，用户根据这些语法定义自己的样式规则，最终会通过解析器，编译生成对应的 CSS 文件,只有在被编译成css后才能够被浏览器识别使用。</p><blockquote><p>好处：</p></blockquote><ul><li><p>结构清晰，便于扩展，易维护。</p></li><li><p>可以方便地屏蔽浏览器私有语法差异。</p></li><li><p>可以轻松实现多重继承。</p></li><li><p>完全兼容 CSS 代码，可以方便地应用到老项目中。</p></li></ul><h2 id="支持内联元素宽高"><a href="#支持内联元素宽高" class="headerlink" title="支持内联元素宽高"></a>支持内联元素宽高</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display:block\inline-block</span><br><span class="line">float:left\right</span><br></pre></td></tr></table></figure><h2 id="css三大特性"><a href="#css三大特性" class="headerlink" title="css三大特性"></a>css三大特性</h2><ul><li>层叠性：通过相同的选择器选中同一个标签，给该标签设置同一个样式，其中一个会覆盖掉另一个</li><li>继承性：给父元素设置样式后，子元素能够应用上父元素的样式 ：以font-（font-size、font-family、font-weight、font-style）   line-（line-height)  text-(text-align、text-decoration、text-indent、text-shadow)  开头的样式 以及 color   是可以继承的</li><li>优先级：<ul><li>优先级计算方式：多个基本选择器的权重相加</li><li>!important 1000  &gt;  id 100  &gt; class 10  &gt;   标签 1   &gt;   * 0</li><li>权重一样，选中的标签一致，遵循就近原则</li><li>权重不同，选中的标签一致，优先使用权重大的样式</li><li>选中不同的标签，遵循继承来的样式优先级没有自己本身优先级高</li><li>！important  优先级高于行间样式，但还是得遵循继承来的样式优先级没有自己本身优先级高</li></ul></li></ul><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC：英文：Block Formatting Context，全称”块级格式化上下文”，BFC：只有块级元素参与的，BFC是指块级元素在页面中如何排列，如何渲染，并且与内部元素无关</p><h3 id="BFC特性"><a href="#BFC特性" class="headerlink" title="BFC特性"></a>BFC特性</h3><ol><li>内部标签在垂直方向上一个接一个的放置</li><li>迟滞方向上的距离是由margin决定，属于同一个BFC的两个相邻标签的margin会发生重叠</li><li>每个标签的左外边距会与包含块的左边距相接触（从左到右），浮动元素也是如此</li><li>BFC区域不会与浮动区域发生重叠</li><li>计算BFC区域的高度时，浮动子元素也参与计算</li><li>BFC就是页面中的一个隔离的独立容器，容器里面的字标签不会影响外面的标签，反之亦然。</li></ol><h3 id="BFC的生成"><a href="#BFC的生成" class="headerlink" title="BFC的生成"></a>BFC的生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根目录</span><br><span class="line">display:inline-block;</span><br><span class="line">float:left|right;</span><br><span class="line">position:absolute|fixed;</span><br><span class="line">overfiow:hidden|auto|scroll;</span><br></pre></td></tr></table></figure><h3 id="BFC解决问题"><a href="#BFC解决问题" class="headerlink" title="BFC解决问题"></a>BFC解决问题</h3><blockquote><p>兄弟元素的外边距塌陷问题<br>产生原因：BFC特性（2）<br>解决方法：让他们处于不同的BFC区域，给其中一个兄弟元素套一个盒子，给父元素设置overflow:hidden</p></blockquote><blockquote><p>两|三栏自适应<br>产生原因：浮动会脱离文档流，但是不脱离文本流，所以左侧盒子浮动之后，右侧盒子中的文字会环绕在左侧盒子的周围<br>解决问题：根据特性（4），可以让右侧盒子处于一个新的BFC区域就不会与浮动区域发生重叠</p></blockquote><blockquote><p>放止文字环绕<br>文字环绕产生的原因：图片浮动会脱离文档流，但是不脱离文本流，左侧盒子中的文字会环绕在图片的周围<br>解决问题：根据特性（4），可以让左侧盒子处于一个新的BFC区域就不会与浮动区域发生重叠</p></blockquote><blockquote><p>清浮动：给父元素添加<code>overflow:hidden</code>清浮动时，根据特性（5），让父元素在BFC区域中，那么计算高度时浮动子元素也会参与计算</p></blockquote><h3 id="css预处理-less"><a href="#css预处理-less" class="headerlink" title="css预处理 less"></a>css预处理 less</h3><ol><li>less 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件,只有在被编译后才能够被浏览器识别使用。</li><li>好处<ul><li>结构清晰，便于扩展</li><li>可以方便地平布浏览器私有语法差异</li><li>可以轻松实现多重继承</li><li>完全兼容css代码，可以方便的用到老项目中</li></ul></li><li>编译工具：<ul><li>Visual Studio Code 插件 easyless</li></ul></li><li>less语法<ul><li>注释：<ul><li>多行注释   /* comment */ ，会保留到编译后的文件。</li><li>单行注释 // comment，只保留在less源文件中，编译后被省略。</li></ul></li><li>@import “导入文件的地址”;（.css 后缀名不能省略，引入 .less 文件可以省略扩展名）</li><li>变量<ul><li>定义：@变量名:值;</li><li>使用：<ul><li>变量以@开头,变量名与变量值之间用【冒号】分隔   width: @变量名;</li><li> 如果变量需要镶嵌在字符串之中，就必须需要写在@{}之中   border-@{dir}:1px solid red;</li></ul></li></ul></li><li>嵌套： 选择器嵌套，在嵌套的代码块内，使用&amp;引用父元素</li><li>继承： &amp;:extend(.box1);</li><li>运算：任何数字、颜色或者变量都可以参与运算；在运算中以()进行优先级计算</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP和HTTPS的理解</title>
      <link href="2021/04/21/HTTP%E5%92%8CHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>2021/04/21/HTTP%E5%92%8CHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP和HTTPS的理解"><a href="#HTTP和HTTPS的理解" class="headerlink" title="HTTP和HTTPS的理解"></a>HTTP和HTTPS的理解</h1><p>感谢原作者，程序员cxuan 详情看这里<a href="https://blog.csdn.net/qq_36894974/article/details/103930478?spm=1001.2014.3001.5501">传送门</a> </p><h2 id="HTTP：是一种超文本传输协议，"><a href="#HTTP：是一种超文本传输协议，" class="headerlink" title="HTTP：是一种超文本传输协议，"></a>HTTP：是一种超文本传输协议，</h2><p>分割：超文本、传输、协议它们之间关系如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDEvMTUxNTExMS0yMDIwMDExMDIwMTIyMzEzMy0xMzAwNDA2NjE4LnBuZw?x-oss-process=image/format,png" alt="img"></p><h3 id="什么是超文本"><a href="#什么是超文本" class="headerlink" title="什么是超文本"></a>什么是超文本</h3><p>互联网早期没有网络，所以信息只能保存在本地，无法与其他电脑交互，所以称之为文本。随着互联网的高速发展，电脑之间可以进行传输的时候，人们想传输图片、音频、视频、甚至点击文字或者图片进行超链接的跳转、那么这种文本就被称之为超文本（得到强化的文本，文本就是普通人，超文本就是基因战士）</p><h3 id="什么是传输"><a href="#什么是传输" class="headerlink" title="什么是传输"></a>什么是传输</h3><p>两台电脑进行通信，储存的超文本就会被解析成为二进制数据包（因为电脑只认识二进制，所以需要进行解析），通过载体（例如同轴电缆、电话线、光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程称之为传输。</p><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><p>网络协议就是网络中传递、管理信息的规范，简单来说就是一种规则一种规定，计算机需要共同遵守一定的规则，这些规则称之为网络协议。</p><p>总的来说就是：<strong>超级文本信息通过载体，遵守网络规则的协议</strong></p><h3 id="HTTP的优缺点："><a href="#HTTP的优缺点：" class="headerlink" title="HTTP的优缺点："></a>HTTP的优缺点：</h3><ul><li>简单、灵活和易于扩展</li><li>应用非常广泛</li><li>HTTP是无状态的，可以轻松实现集群化，扩展性能</li><li>明文传输，数据完全肉眼可见，能够方便的研究和分析，但是也容易被窃听</li><li>HTTP是不安全的，无法验证通信双方的身份，也不能判断报文是否被修改（个人理解不能验证你的信息，也不能检验你的数据是否被修改）</li></ul><h2 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h2><p>​    基于HTTP协议，通过SSL或TLS提供加密处理数据、校验对方身份以及数据的完整性保护</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>内容加密：采用混合加密技术，中间无法直接查明文内容</li><li>验证身份：通过证书认证客户端访问的是自己的服务器</li><li>保护数据的完整性：防止传输的内容被中间人冒充或者篡改</li></ul>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http与https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo报错Spawn failed解决方法</title>
      <link href="2021/04/13/hexo%E6%8A%A5%E9%94%99Spawn%20failed%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2021/04/13/hexo%E6%8A%A5%E9%94%99Spawn%20failed%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="再部署过程中-有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。"><a href="#再部署过程中-有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。" class="headerlink" title="再部署过程中 有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。"></a>再部署过程中 有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。</h2><h3 id="来自大佬分享-传送门"><a href="#来自大佬分享-传送门" class="headerlink" title="来自大佬分享 传送门"></a>来自大佬分享 <a href="https://blog.zhheo.com/p/128998ac.html">传送门</a></h3><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (E:\banmaya\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (node:events:379:20)</span><br><span class="line">      at ChildProcess.cp.emit (E:\banmaya\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (node:internal&#x2F;child_process:285:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解决方法一（自己常用）"><a href="#解决方法一（自己常用）" class="headerlink" title="解决方法一（自己常用）"></a>解决方法一（自己常用）</h3><p>不过在使用过程中发现，每次都需要进行这样的操作，并且可能第一次不会成功，需要几次操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="解决方法二（用过一次，但是第二次就不行，不知道为什么）"><a href="#解决方法二（用过一次，但是第二次就不行，不知道为什么）" class="headerlink" title="解决方法二（用过一次，但是第二次就不行，不知道为什么）"></a>解决方法二（用过一次，但是第二次就不行，不知道为什么）</h3><p><a href="https://1187100546.github.io/2019/11/24/spawn-failed/">huahua</a>提供的方法，删除博客根目录文件夹中的<code>.deploy_git</code>文件夹，然后在博客根目录下输入<code>git config --global core.autocrlf false</code></p><h3 id="解决方法三（未验证）"><a href="#解决方法三（未验证）" class="headerlink" title="解决方法三（未验证）"></a>解决方法三（未验证）</h3><p><a href="http://ciraos.top/">小青</a>提供的方法：找到<code>.deploy_git</code>文件夹中的<code>index.lock</code>文件，删除就好了。</p><h3 id="解决方式四（不推荐）"><a href="#解决方式四（不推荐）" class="headerlink" title="解决方式四（不推荐）"></a>解决方式四（不推荐）</h3><p>cd进<code>.deploy_git</code>文件夹，然后使用<code>git push -f</code>强制推送</p><h3 id="解决方法五"><a href="#解决方法五" class="headerlink" title="解决方法五"></a>解决方法五</h3><p><a href="https://perry96.com/archives/882898e3.html">Perry</a>提供的方法：打开<code>.deploy_git\.git\logs</code>路径下的<code>HEAD</code>查看最近一次正确的那次的<code>commitId</code>然后用<code>git reset --hard commitId</code>回滚</p><p>每个方法最后进行hexo三连操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
