<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>html及css总结</title>
      <link href="2021/04/27/html%E5%8F%8Acss%E6%80%BB%E7%BB%93/"/>
      <url>2021/04/27/html%E5%8F%8Acss%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="html及css总结"><a href="#html及css总结" class="headerlink" title="html及css总结"></a>html及css总结</h1><h2 id="常见浏览器及内核"><a href="#常见浏览器及内核" class="headerlink" title="常见浏览器及内核"></a>常见浏览器及内核</h2><blockquote><p>浏览器：IE、谷歌、火狐、苹果、欧朋</p><p>内核：Trident、Blink、Gecko、Webkit、Blink</p></blockquote><h2 id="b和strong（i和em）标签的区别"><a href="#b和strong（i和em）标签的区别" class="headerlink" title="b和strong（i和em）标签的区别"></a>b和strong（i和em）标签的区别</h2><blockquote><p>b标签为一个实体标签，被包围的字符设为粗体</p><p>strong标签更加有语义化（推荐使用）</p><p>i标签为倾斜</p><p>em标签更有强调意义的倾斜</p></blockquote><h2 id="引入css的方式有几种"><a href="#引入css的方式有几种" class="headerlink" title="引入css的方式有几种"></a>引入css的方式有几种</h2><blockquote><p>（1）内嵌式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过&lt;style&gt;&lt;&#x2F;style&gt;来书写CSS代码。</span><br><span class="line">只能应用于当前网页，不能被其它网页共享。</span><br><span class="line">注意：&lt;style&gt;标记可以放在网页的任何地方，但一般放在&lt;head&gt;。</span><br></pre></td></tr></table></figure><blockquote><p>（2）外联式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过&lt;link&gt;标记来引入外部的CSS文件(.css)。</span><br><span class="line">可以被其它网页共享。</span><br><span class="line">格式：&lt;link href&#x3D;&quot;CSS的URL&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;&gt;</span><br><span class="line">注意：&lt;link&gt;标记只能放在&lt;head&gt;中</span><br></pre></td></tr></table></figure><blockquote><p>（3）行内样式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过style的属性来书写CSS代码。</span><br><span class="line">举例：&lt;p style&#x3D;&quot;font-size:24px;&quot;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><h2 id="单行文本水平垂直居中如何实现"><a href="#单行文本水平垂直居中如何实现" class="headerlink" title="单行文本水平垂直居中如何实现"></a>单行文本水平垂直居中如何实现</h2><blockquote><p>1、水平居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text-align:center;控制单行文字水平居中</span><br></pre></td></tr></table></figure><blockquote><p>2、垂直居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置行高，line-height:与元素高度相等的值</span><br></pre></td></tr></table></figure><h2 id="选择器优先级如何计算"><a href="#选择器优先级如何计算" class="headerlink" title="选择器优先级如何计算"></a>选择器优先级如何计算</h2><ul><li><p>选择器优先级与权值相关</p></li><li><p>基础选择器的权值：通配符选择器（0）、标签选择器（1）、class选择器（10）、id选择器（100）</p></li><li><p>复合选择器的权值是所有的单一选择器权值的累加</p></li><li><p>权值越大，优先级越高；权值相同，后写的会覆盖先写的</p></li><li><p>继承样式没有权值，权值比0小，子元素设置样式会覆盖继承样式</p></li><li><p>行间样式权值为1000，优于id选择器</p></li><li><p>!important优于行间样式</p></li></ul><h2 id="那些css属性可以继承"><a href="#那些css属性可以继承" class="headerlink" title="那些css属性可以继承"></a>那些css属性可以继承</h2><blockquote><p>1、字体系列属性</p></blockquote><p>　　font-family：字体系列</p><p>　　font-weight：字体的粗细</p><p>　　font-size：字体的大小</p><p>　　font-style：字体的风格</p><p>　　line-height：行高</p><blockquote><p>2、文本系列属性</p></blockquote><p>　　text-indent：文本缩进</p><p>　　text-align：文本水平对齐</p><p>　　color：文本颜色</p><blockquote><p>3、 list-style属性</p></blockquote><h2 id="margin-存在问题"><a href="#margin-存在问题" class="headerlink" title="margin 存在问题"></a>margin 存在问题</h2><blockquote><p>重叠问题</p></blockquote><p>问题：两格兄弟元素同时设置margin-top和margin-bottom，会重叠，取最大值。</p><p>解决方案;</p><ul><li>避免同时使用，只需要一方使用</li><li>给其中一个盒子套一个大盒子包起来，给大盒子设置overflow:hidden;形成私有区域</li></ul><blockquote><p>塌陷问题</p></blockquote><p>问题：父元素的第一个子元素设置margin-top会传递给父元素</p><p>解决方案：</p><ul><li>避免使用margin-top</li><li>给父元素设置<ul><li>podding-top:1px</li><li>border-top:1px solid red;</li><li>overflow:hidden;私有区域</li></ul></li></ul><h2 id="浮动产生的问题？清除浮动的方案？"><a href="#浮动产生的问题？清除浮动的方案？" class="headerlink" title="浮动产生的问题？清除浮动的方案？"></a>浮动产生的问题？清除浮动的方案？</h2><blockquote><p>浮动元素引起的问题：</p></blockquote><p>浮动元素脱离文档流之后在文档流中不占位，父元素的高度无法被撑开，影响与父元素同级的元素</p><blockquote><p>清楚浮动的方法：</p></blockquote><p>（1）给父级元素加高度（不推荐使用，它只适合高度固定的布局，一般父盒子都是为由内容撑起来）</p><p>（2）在浮动元素的结尾处添加空div标签clear:both。具体做法：添加一个div标签并定义一个clear的类名，给clear类名添加样式clear:both，将该div标签放到父元素内容结束前的位置（缺点：会多加CSS和HTML标签）。</p><p>（3）给父级元素定义 overflow:hidden（推荐使用，缺点：不能和position配合使用，因为超出的尺寸的会被隐藏）</p><p>（4）给父级div定义伪类：after和zoom（推荐使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">清除浮动代码*&#x2F; .clearfix:after&#123;content:&quot;&quot;;display:block;clear:both;visibility:hidden;height:0&#125; .clearfix&#123;zoom:1&#125;</span><br></pre></td></tr></table></figure><p>然后父级元素添加clearfix类名即可</p><p>（5）给父级元素添加浮动（缺点：会产生新的浮动问题）</p><h2 id="BFC规则特性，及解决的问题？"><a href="#BFC规则特性，及解决的问题？" class="headerlink" title="BFC规则特性，及解决的问题？"></a>BFC规则特性，及解决的问题？</h2><blockquote><p>BFC规则</p></blockquote><ul><li><p>我的理解是：只有块级元素参与，BFC是指块级元素在页面中如何排列，如何渲染，并且与内部元素无关-</p></li><li><p>内部的标签会在垂直方向上一个接一个的放置</p><p>垂直方向上的距离由margin决定，属于同一个BFC的两个相邻标签的margin会发生重叠</p><p>每个标签的左外边距与包含块的左边界相接触（从左向右），即使浮动标签也是如此。</p><p>BFC的区域不会与float的标签区域重叠</p><p>计算BFC的高度时，浮动子标签也参与计算</p><p>BFC就是页面上的一个隔离的独立容器，容器里面的子标签不会影响到外面标签，反之亦然</p></li></ul><blockquote><p>BFC解决的问题</p></blockquote><h4 id="解决外边距折叠"><a href="#解决外边距折叠" class="headerlink" title="解决外边距折叠"></a>解决外边距折叠</h4><p>特性的第②条：垂直方向上的距离由margin决定。在常规文档流中，两个兄弟盒子之间的垂直距离是由他们的外边距所决定的，但不是他们的两个外边距之和，而是以较大的为准。特性的第⑥条：bfc就是页面上的一个独立容器，容器里面的子标签不会影响外面标签，同样外面的标签不会影响到BFC内的标签。所以可以让其中的一个标签处于一个BFC中</p><h4 id="自适应两栏或三栏布局"><a href="#自适应两栏或三栏布局" class="headerlink" title="自适应两栏或三栏布局"></a>自适应两栏或三栏布局</h4><p>左边固定宽度，右边不设宽，因此右边的宽度自适应，随浏览器窗口大小的变化而变化。</p><p>左右两边固定宽度，中间不设宽，因此中间的宽度自适应，随浏览器的大小变化而变化。</p><p>浮动的标签会覆盖正常标签根据第④条规则，BFC的区域不会与float的标签区域重叠，</p><p>所以我们只需要创建一个BFC，它就会自动缩小，以不被浮动的标签遮盖，就能够实现右侧栏自适应。</p><h4 id="防止字体环绕"><a href="#防止字体环绕" class="headerlink" title="防止字体环绕"></a>防止字体环绕</h4><p>浮动的盒子会遮盖下面的盒子，但是下面盒子里的文字是不会被遮盖的，文字反而还会环绕浮动的盒子。</p><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>利用overflow:hidden清除浮动，因为浮动的盒子无法撑出处于标准文档流的父盒子的height。根据特性第⑤条。计算BFC的高度时，浮动子标签也参与计算。</p><h2 id="图片间隙问题，如何解决"><a href="#图片间隙问题，如何解决" class="headerlink" title="图片间隙问题，如何解决"></a>图片间隙问题，如何解决</h2><p>方法 1：将图片显示为块：解决下方间隙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:block;</span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure><p>方法 2：改变图片的 vertical-align :解决下方间隙</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">vertical-align</span>:middle; </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>除了 middle值，还可以设置为 top| bottom 等</p><p>方法 3：设置图片父级标签的 font-size:0;line-height:0; 水平间隙，图片下方间隙都能解决</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.imgwrap</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">0</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><h2 id="圣杯布局、双飞翼布局的实现原理"><a href="#圣杯布局、双飞翼布局的实现原理" class="headerlink" title="圣杯布局、双飞翼布局的实现原理"></a>圣杯布局、双飞翼布局的实现原理</h2><ul><li>圣杯布局<ul><li>HTML结构中，先主体内容后侧边</li><li>两侧宽度固定，中间宽度设置100%</li><li>两侧盒子和中间盒分别加浮动</li><li>将左侧盒子拉到最左边，将右侧盒子拉到最右边</li><li>通过左、中、右盒子的父级盒将中间内容露出来</li><li>分别还原左侧盒子和右侧盒子</li></ul></li><li>双飞翼布局<ul><li>HTML结构中，先主体结构后侧边</li><li>两侧宽度固定，中间宽度设置100%</li><li>两侧盒子和中间盒分别加浮动</li><li>将左侧盒子拉到最左边，将右侧盒子拉到最右边</li><li>在主体结构盒的子盒上设置margin值，将中间内容露出来</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/quruidong/blogFigureBed/img/20210427162150.png"></p><h2 id="精灵图的原理及优缺点？"><a href="#精灵图的原理及优缺点？" class="headerlink" title="精灵图的原理及优缺点？"></a>精灵图的原理及优缺点？</h2><p>英文叫法 css sprites，通常被解释为“CSS 图像拼合”或“CSS 贴图定位”；其实就</p><p>是把网页中一些背景图片整合到一张图片文件中，再利用 CSS “background-image”，</p><p>“background- repeat”，“background-position”的组合进行背景定位，background-position 用数字能精确的定位出背景图片的位置。适用于一般小图标，不适合大背景大布局背景</p><blockquote><p>优点：</p></blockquote><p>（1）减少网页的 http 请求，从而大大的提高页面的性能</p><p>（2）图片命名上的困扰</p><p>（3）更换风格方便</p><blockquote><p>缺点：</p></blockquote><p>（1）必须要限定容器大小符合背景图元素位置，需要计算</p><h2 id="html5的新特性"><a href="#html5的新特性" class="headerlink" title="html5的新特性"></a>html5的新特性</h2><ul><li><p>新增语义化的标签</p></li><li><p>新增表单元素和表单属性</p></li><li><p>新增网页上绘制图形的canvas元素</p></li><li><p>新增多媒体相关的video和audio</p></li><li><p>对本地离线存储的更好支持</p></li></ul><h2 id="处理HTML5新标签的浏览器兼容问题"><a href="#处理HTML5新标签的浏览器兼容问题" class="headerlink" title="处理HTML5新标签的浏览器兼容问题"></a>处理HTML5新标签的浏览器兼容问题</h2><p>HTML5新标签对IE低版本浏览器的影响及兼容情况处理方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方案一：使用javascript新增元素的方法解决</span><br><span class="line">document.createElement(“header”);</span><br><span class="line">document.createElement(“footer”);</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>由于创建出来的元素是内联元素，所以需要转换成块级，宽度和高度才能生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header,footer&#123; display:block;&#125;</span><br></pre></td></tr></table></figure><p>方案二：使用封装好的插件html5shiv.js解决兼容性问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;  src&#x3D;&quot;.&#x2F;html5shiv.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><p>上面这段代码仅会在IE浏览器下运行。</p><h2 id="响应式设计？响应式设计的基本原理？响应式优缺点？"><a href="#响应式设计？响应式设计的基本原理？响应式优缺点？" class="headerlink" title="响应式设计？响应式设计的基本原理？响应式优缺点？"></a>响应式设计？响应式设计的基本原理？响应式优缺点？</h2><p>页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。</p><p>响应式布局可以根据屏幕的大小自动的调整页面的展现方式，以及布局。响应式布局是根据设备屏幕宽度不同适当调整标签显示布局，在每种设备屏幕宽度的设备下呈现的界面是不同的。</p><blockquote><p>响应式网站的优点：</p></blockquote><ul><li><p>减少工作量 网站、设计、代码、内容都 只需要一份，多出来的工作量只是JS脚本、CSS样式做一些改变              </p></li><li><p>节省时间</p></li><li><p>每个设备都能得到正确的设计</p></li></ul><blockquote><p>响应式网站的缺点：</p></blockquote><ul><li><p>会加载更多的样式和脚本资源</p></li><li><p>设计比较难精确定位和控制</p></li><li><p>老版本浏览器兼容不好</p></li></ul><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><p>盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。</p><p>元素框的总宽度 = 元素（element）的width + padding的左边距和右边距的值 + margin的左边距和右边距的值 + border的左右宽度；</p><p>元素框的总高度 = 元素（element）的height + padding的上下边距的值 + margin的上下边距的值 ＋ border的上下宽度。</p><blockquote><p>简单来说</p><p>​    就是每一个标签所占的位置就是盒模型</p><p>盒模型的计算：</p><p>​    宽高+matgin+padding+border</p></blockquote><h2 id="使用定位实现盒子水平垂直居中的代码"><a href="#使用定位实现盒子水平垂直居中的代码" class="headerlink" title="使用定位实现盒子水平垂直居中的代码"></a>使用定位实现盒子水平垂直居中的代码</h2><p>一、定位+margin负值，盒子有宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father&#123; position:relative;&#125;</span><br><span class="line">.son&#123;position:absolute;left:50%;margin-left:-小盒子宽度的一半，top：50%；margin-top：-小盒子高度的一半&#125;</span><br></pre></td></tr></table></figure><p>二、定位+margin：auto，盒子有宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.father&#123; position:relative;&#125;</span><br><span class="line">.son&#123;position:absolute;left：0；top：0；right：0；bottom：0；margin：auto&#125;</span><br></pre></td></tr></table></figure><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>LESS是一种动态语言，属于CSS预处理语言的一种,它扩展了 CSS 语言，使 CSS 更易维护和扩展,可以更便捷的进行 Web 开发，使css的编写有编程思想。</p><p>Less 包含一套自定义的语法，用户根据这些语法定义自己的样式规则，最终会通过解析器，编译生成对应的 CSS 文件,只有在被编译成css后才能够被浏览器识别使用。</p><blockquote><p>好处：</p></blockquote><ul><li><p>结构清晰，便于扩展，易维护。</p></li><li><p>可以方便地屏蔽浏览器私有语法差异。</p></li><li><p>可以轻松实现多重继承。</p></li><li><p>完全兼容 CSS 代码，可以方便地应用到老项目中。</p></li></ul><h2 id="支持内联元素宽高"><a href="#支持内联元素宽高" class="headerlink" title="支持内联元素宽高"></a>支持内联元素宽高</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">display:block\inline-block</span><br><span class="line">float:left\right</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP和HTTPS的理解</title>
      <link href="2021/04/21/HTTP%E5%92%8CHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>2021/04/21/HTTP%E5%92%8CHTTPS%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP和HTTPS的理解"><a href="#HTTP和HTTPS的理解" class="headerlink" title="HTTP和HTTPS的理解"></a>HTTP和HTTPS的理解</h1><p>感谢原作者，程序员cxuan 详情看这里<a href="https://blog.csdn.net/qq_36894974/article/details/103930478?spm=1001.2014.3001.5501">传送门</a> </p><h2 id="HTTP：是一种超文本传输协议，"><a href="#HTTP：是一种超文本传输协议，" class="headerlink" title="HTTP：是一种超文本传输协议，"></a>HTTP：是一种超文本传输协议，</h2><p>分割：超文本、传输、协议它们之间关系如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDEvMTUxNTExMS0yMDIwMDExMDIwMTIyMzEzMy0xMzAwNDA2NjE4LnBuZw?x-oss-process=image/format,png" alt="img"></p><h3 id="什么是超文本"><a href="#什么是超文本" class="headerlink" title="什么是超文本"></a>什么是超文本</h3><p>互联网早期没有网络，所以信息只能保存在本地，无法与其他电脑交互，所以称之为文本。随着互联网的高速发展，电脑之间可以进行传输的时候，人们想传输图片、音频、视频、甚至点击文字或者图片进行超链接的跳转、那么这种文本就被称之为超文本（得到强化的文本，文本就是普通人，超文本就是基因战士）</p><h3 id="什么是传输"><a href="#什么是传输" class="headerlink" title="什么是传输"></a>什么是传输</h3><p>两台电脑进行通信，储存的超文本就会被解析成为二进制数据包（因为电脑只认识二进制，所以需要进行解析），通过载体（例如同轴电缆、电话线、光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程称之为传输。</p><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><p>网络协议就是网络中传递、管理信息的规范，简单来说就是一种规则一种规定，计算机需要共同遵守一定的规则，这些规则称之为网络协议。</p><p>总的来说就是：<strong>超级文本信息通过载体，遵守网络规则的协议</strong></p><h3 id="HTTP的优缺点："><a href="#HTTP的优缺点：" class="headerlink" title="HTTP的优缺点："></a>HTTP的优缺点：</h3><ul><li>简单、灵活和易于扩展</li><li>应用非常广泛</li><li>HTTP是无状态的，可以轻松实现集群化，扩展性能</li><li>明文传输，数据完全肉眼可见，能够方便的研究和分析，但是也容易被窃听</li><li>HTTP是不安全的，无法验证通信双方的身份，也不能判断报文是否被修改（个人理解不能验证你的信息，也不能检验你的数据是否被修改）</li></ul><h2 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a>HTTPS：</h2><p>​    基于HTTP协议，通过SSL或TLS提供加密处理数据、校验对方身份以及数据的完整性保护</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>内容加密：采用混合加密技术，中间无法直接查明文内容</li><li>验证身份：通过证书认证客户端访问的是自己的服务器</li><li>保护数据的完整性：防止传输的内容被中间人冒充或者篡改</li></ul><blockquote><p><strong>欢迎来到<a href="http://qrdd.gitee.io/blog/">搬码鸭の博客</a>呀！</strong><br><strong>博客朋友们如果提问没有的到回复，可以去<a href="https://blog.csdn.net/m0_56737433?spm=1000.2115.3001.5343">CSDN</a>相应的文章下评论，谢谢！</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo报错Spawn failed解决方法</title>
      <link href="2021/04/13/hexo%E6%8A%A5%E9%94%99Spawn%20failed%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2021/04/13/hexo%E6%8A%A5%E9%94%99Spawn%20failed%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="再部署过程中-有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。"><a href="#再部署过程中-有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。" class="headerlink" title="再部署过程中 有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。"></a>再部署过程中 有的时候会部署不上，具体原因是什么还不清楚，问过群友后有以下解决方法，我也发现了另为一种解决方法，分享给大家。</h2><h3 id="来自大佬分享-传送门"><a href="#来自大佬分享-传送门" class="headerlink" title="来自大佬分享 传送门"></a>来自大佬分享 <a href="https://blog.zhheo.com/p/128998ac.html">传送门</a></h3><p>报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (E:\banmaya\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (node:events:379:20)</span><br><span class="line">      at ChildProcess.cp.emit (E:\banmaya\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (node:internal&#x2F;child_process:285:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解决方法一（自己常用）"><a href="#解决方法一（自己常用）" class="headerlink" title="解决方法一（自己常用）"></a>解决方法一（自己常用）</h3><p>不过在使用过程中发现，每次都需要进行这样的操作，并且可能第一次不会成功，需要几次操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="解决方法二（用过一次，但是第二次就不行，不知道为什么）"><a href="#解决方法二（用过一次，但是第二次就不行，不知道为什么）" class="headerlink" title="解决方法二（用过一次，但是第二次就不行，不知道为什么）"></a>解决方法二（用过一次，但是第二次就不行，不知道为什么）</h3><p><a href="https://1187100546.github.io/2019/11/24/spawn-failed/">huahua</a>提供的方法，删除博客根目录文件夹中的<code>.deploy_git</code>文件夹，然后在博客根目录下输入<code>git config --global core.autocrlf false</code></p><h3 id="解决方法三（未验证）"><a href="#解决方法三（未验证）" class="headerlink" title="解决方法三（未验证）"></a>解决方法三（未验证）</h3><p><a href="http://ciraos.top/">小青</a>提供的方法：找到<code>.deploy_git</code>文件夹中的<code>index.lock</code>文件，删除就好了。</p><h3 id="解决方式四（不推荐）"><a href="#解决方式四（不推荐）" class="headerlink" title="解决方式四（不推荐）"></a>解决方式四（不推荐）</h3><p>cd进<code>.deploy_git</code>文件夹，然后使用<code>git push -f</code>强制推送</p><h3 id="解决方法五"><a href="#解决方法五" class="headerlink" title="解决方法五"></a>解决方法五</h3><p><a href="https://perry96.com/archives/882898e3.html">Perry</a>提供的方法：打开<code>.deploy_git\.git\logs</code>路径下的<code>HEAD</code>查看最近一次正确的那次的<code>commitId</code>然后用<code>git reset --hard commitId</code>回滚</p><p>每个方法最后进行hexo三连操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
